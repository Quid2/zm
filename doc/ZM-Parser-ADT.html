<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>ZM.Parser.ADT</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">zm-0.3.9: Language independent, reproducible, absolute types</span><ul class="links" id="page-menu"><li><a href="src/ZM.Parser.ADT.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">ZM.Parser.ADT</p></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:adts">adts</a> :: <a href="ZM-Parser-Types.html#t:Parser" title="ZM.Parser.Types">Parser</a> [<a href="ZM-Parser-Types.html#t:ADTParts" title="ZM.Parser.Types">ADTParts</a>]</li><li class="src short"><a href="#v:adt">adt</a> :: <a href="ZM-Parser-Types.html#t:Parser" title="ZM.Parser.Types">Parser</a> <a href="ZM-Parser-Types.html#t:ADTParts" title="ZM.Parser.Types">ADTParts</a></li><li class="src short"><a href="#v:parType">parType</a> :: <a href="ZM-Parser-Types.html#t:Parser" title="ZM.Parser.Types">Parser</a> a -&gt; <a href="ZM-Parser-Types.html#t:Parser" title="ZM.Parser.Types">Parser</a> (<a href="ZM-Types.html#t:Type" title="ZM.Types">Type</a> a)</li><li class="src short"><a href="#v:absReference">absReference</a> :: <a href="ZM-Parser-Types.html#t:Parser" title="ZM.Parser.Types">Parser</a> <a href="ZM-Types.html#t:AbsRef" title="ZM.Types">AbsRef</a></li><li class="src short"><a href="#v:maybeNamedAbsRef">maybeNamedAbsRef</a> :: <a href="ZM-Parser-Types.html#t:Parser" title="ZM.Parser.Types">Parser</a> (<a href="ZM-Parser-Types.html#t:TypeName" title="ZM.Parser.Types">TypeName</a> <a href="ZM-Types.html#t:Identifier" title="ZM.Types">Identifier</a>)</li><li class="src short"><a href="#v:namedOrAbsRef">namedOrAbsRef</a> :: <a href="ZM-Parser-Types.html#t:Parser" title="ZM.Parser.Types">Parser</a> (<a href="ZM-Parser-Types.html#t:TypeName" title="ZM.Parser.Types">TypeName</a> <a href="ZM-Types.html#t:Identifier" title="ZM.Types">Identifier</a>)</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:adts" class="def">adts</a> :: <a href="ZM-Parser-Types.html#t:Parser" title="ZM.Parser.Types">Parser</a> [<a href="ZM-Parser-Types.html#t:ADTParts" title="ZM.Parser.Types">ADTParts</a>] <a href="src/ZM.Parser.ADT.html#adts" class="link">Source</a> <a href="#v:adts" class="selflink">#</a></p><div class="doc"><p>Parse a, possibly empty, group of ZM ADT declarations.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parseMaybe adts &quot;&quot;
</code></strong>Just []
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>putStr $ prettyShow $ parseMaybe adts &quot;Void;&quot;
</code></strong>Just [Void@(0:0-3) =]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>putStr $ prettyShow $ parseMaybe adts &quot;Void;Bool=False | True&quot;
</code></strong>Just [Void@(0:0-3) =,
      Bool@(0:5-8) = False@(0:10-14) | True@(0:18-21)]
</pre></div></div><div class="top"><p class="src"><a id="v:adt" class="def">adt</a> :: <a href="ZM-Parser-Types.html#t:Parser" title="ZM.Parser.Types">Parser</a> <a href="ZM-Parser-Types.html#t:ADTParts" title="ZM.Parser.Types">ADTParts</a> <a href="src/ZM.Parser.ADT.html#adt" class="link">Source</a> <a href="#v:adt" class="selflink">#</a></p><div class="doc"><p>Parse a ZM ADT declaration.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>putStr $ prettyShow $ parseMaybe adt &quot;Void&quot;
</code></strong>Just Void@(0:0-3) =
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>putStr $ prettyShow $ parseMaybe adt &quot;Bool.K306f1981b41c = False \n| True&quot;
</code></strong>Just Bool.K306f1981b41c@(0:0-17) = False@(0:21-25) | True@(1:2-5)
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>putStr $ prettyShow $ parseMaybe adt &quot;&#26159;&#19981;&#26159; &#8801;   &#26159;\n                    | &#19981;&#26159;&quot;
</code></strong>Just &#26159;&#19981;&#26159;@(0:0-2) = &#26159;@(0:8) | &#19981;&#26159;@(1:22-23)
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>putStr $ prettyShow $ parseMaybe adt &quot;A = A (A (B C D))&quot;
</code></strong>Just A@(0:0) = A@(0:4) (A@(0:7) (B@(0:10) C@(0:12) D@(0:14)))
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>putStr $ prettyShow $ parseMaybe adt &quot;Msg = Msg {from:Name.K306f1981b41c,subject:String}&quot;
</code></strong>Just Msg@(0:0-2) = Msg@(0:6-8) {from@(0:11-14) :: Name.K306f1981b41c@(0:16-33),
                                subject@(0:35-41) :: String@(0:43-48)}
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>putStr $ prettyShow $ parseMaybe adt &quot;List a = Cons {head:a, tail:List a} | \nNil&quot;
</code></strong>Just List@(0:0-3) a@(0:5) = Cons@(0:9-12) {head@(0:15-18) :: a@(0:20),
                                           tail@(0:23-26) :: List@(0:28-31) a@(0:33)} | Nil@(1:0-2)
</pre><p>Syntax Errors:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>putStr $ prettyShow $ parseDoc adt &quot;Bool = | True&quot;
</code></strong>Left &quot;unexpected '|' expecting end of input or letter&quot;@(0:7)
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>putStr $ prettyShow $ parseDoc adt &quot; = &quot;
</code></strong>Left &quot;unexpected '=' expecting letter&quot;@(0:1)
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>putStr $ prettyShow $ parseDoc adt &quot;a b.d e.f = c.f.a&quot;
</code></strong>Left &quot;unexpected '.' expecting '=', '_', '\8801', alphanumeric character, end of input, or letter&quot;@(0:3)
</pre></div></div><div class="top"><p class="src"><a id="v:parType" class="def">parType</a> :: <a href="ZM-Parser-Types.html#t:Parser" title="ZM.Parser.Types">Parser</a> a -&gt; <a href="ZM-Parser-Types.html#t:Parser" title="ZM.Parser.Types">Parser</a> (<a href="ZM-Types.html#t:Type" title="ZM.Types">Type</a> a) <a href="src/ZM.Parser.ADT.html#parType" class="link">Source</a> <a href="#v:parType" class="selflink">#</a></p><div class="doc"><p>Parse a type application, a type constructor with zero or more parameters</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parseMaybe (parType localId) &quot;a&quot;
</code></strong>Just (TypeCon &quot;a&quot;)
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parseMaybe (parType localId) &quot;((a))&quot;
</code></strong>Just (TypeCon &quot;a&quot;)
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parseMaybe (parType localId) &quot;a b&quot;
</code></strong>Just (TypeApp (TypeCon &quot;a&quot;) (TypeCon &quot;b&quot;))
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parseMaybe (parType localId) &quot;(a) ((b)) c&quot;
</code></strong>Just (TypeApp (TypeApp (TypeCon &quot;a&quot;) (TypeCon &quot;b&quot;)) (TypeCon &quot;c&quot;))
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>typeN &lt;$&gt; parseMaybe (parType localId) &quot;(a b (c d (e f g))) z&quot;
</code></strong>Just (TypeN &quot;a&quot; [TypeN &quot;b&quot; [],TypeN &quot;c&quot; [TypeN &quot;d&quot; [],TypeN &quot;e&quot; [TypeN &quot;f&quot; [],TypeN &quot;g&quot; []]],TypeN &quot;z&quot; []])
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parseMaybe (parType localId) &quot;(a b) c&quot;
</code></strong>Just (TypeApp (TypeApp (TypeCon &quot;a&quot;) (TypeCon &quot;b&quot;)) (TypeCon &quot;c&quot;))
</pre></div></div><div class="top"><p class="src"><a id="v:absReference" class="def">absReference</a> :: <a href="ZM-Parser-Types.html#t:Parser" title="ZM.Parser.Types">Parser</a> <a href="ZM-Types.html#t:AbsRef" title="ZM.Types">AbsRef</a> <a href="src/ZM.Parser.ADT.html#absReference" class="link">Source</a> <a href="#v:absReference" class="selflink">#</a></p><div class="doc"><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prettyShow &lt;$&gt; parseMaybe absReference &quot;K306f1981b41c&quot;
</code></strong>Just &quot;K306f1981b41c&quot;
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prettyShow &lt;$&gt; parseMaybe absReference &quot;KKK&quot;
</code></strong>Nothing
</pre></div></div><div class="top"><p class="src"><a id="v:maybeNamedAbsRef" class="def">maybeNamedAbsRef</a> :: <a href="ZM-Parser-Types.html#t:Parser" title="ZM.Parser.Types">Parser</a> (<a href="ZM-Parser-Types.html#t:TypeName" title="ZM.Parser.Types">TypeName</a> <a href="ZM-Types.html#t:Identifier" title="ZM.Types">Identifier</a>) <a href="src/ZM.Parser.ADT.html#maybeNamedAbsRef" class="link">Source</a> <a href="#v:maybeNamedAbsRef" class="selflink">#</a></p><div class="doc"><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prettyShow &lt;$&gt; parseMaybe maybeNamedAbsRef &quot;Bool.K306f1981b41c&quot;
</code></strong>Just &quot;Bool.K306f1981b41c&quot;
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prettyShow &lt;$&gt; parseMaybe maybeNamedAbsRef &quot;.K306f1981b41c&quot;
</code></strong>Just &quot;.K306f1981b41c&quot;
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prettyShow &lt;$&gt; parseMaybe maybeNamedAbsRef &quot;K306f1981b41c&quot;
</code></strong>Just &quot;.K306f1981b41c&quot;
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prettyShow &lt;$&gt; parseMaybe maybeNamedAbsRef &quot;Bool&quot;
</code></strong>Nothing
</pre></div></div><div class="top"><p class="src"><a id="v:namedOrAbsRef" class="def">namedOrAbsRef</a> :: <a href="ZM-Parser-Types.html#t:Parser" title="ZM.Parser.Types">Parser</a> (<a href="ZM-Parser-Types.html#t:TypeName" title="ZM.Parser.Types">TypeName</a> <a href="ZM-Types.html#t:Identifier" title="ZM.Types">Identifier</a>) <a href="src/ZM.Parser.ADT.html#namedOrAbsRef" class="link">Source</a> <a href="#v:namedOrAbsRef" class="selflink">#</a></p><div class="doc"><p>Parse a simple type name, possibly qualified with an absolute code.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prettyShow &lt;$&gt; parseMaybe namedOrAbsRef &quot;nil&quot;
</code></strong>Just &quot;nil&quot;
</pre><p>The . is required to distinguish a hash from a plain type name (remove this ambiguity?)</p><p>This is a hash:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parseMaybe namedOrAbsRef &quot;.K306f1981b41c&quot;
</code></strong>Just (That (AbsRef (SHAKE128_48 48 111 25 129 180 28)))
</pre><p>And this is just a type name (NO actually we try to interpret it as an absolute reference first):</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parseMaybe namedOrAbsRef &quot;K306f1981b41c&quot;
</code></strong>Just (That (AbsRef (SHAKE128_48 48 111 25 129 180 28)))
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.24.2</p></div></body></html>