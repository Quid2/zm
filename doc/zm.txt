-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Language independent, reproducible, absolute types
--   
--   See the <a>online tutorial</a>.
@package zm
@version 0.3.9


-- | Crypto algorithms of the Keccak family (SHA3/SHAKE), with support for
--   GHCJS.
module Data.Digest.Keccak

-- | Return the specified number of bytes of the SHA-3 hash of the provided
--   byte string
sha3_256 :: Int -> ByteString -> ByteString

-- | Return the specified number of bytes of the SHAKE-128 hash of the
--   provided byte string &gt;&gt;&gt; shake_128 8 B.empty == B.pack [127,
--   156, 43, 164, 232, 143, 130, 125] True
--   
--   <pre>
--   &gt;&gt;&gt; shake_128 32 (B.pack [1..10]) == B.pack [142,56,168,122,207,188,35,211,233,209,95,158,63,91,102,156,114,204,22,38,177,105,130,116,173,114,190,153,159,101,10,150]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let i = B.pack [1..10] in shake_128 4 i == B.take 4 (shake_128 32 i)
--   True
--   </pre>
shake_128 :: Int -> ByteString -> ByteString

module Data.List.Extra

-- | Non-recursive transform over a list, like maybe.
--   
--   <pre>
--   &gt;&gt;&gt; list 1 (\v _ -&gt; v - 2) []
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; list 1 (\v _ -&gt; v - 2) [5,6,7]
--   3
--   </pre>
list :: b -> (a -> [a] -> b) -> [a] -> b

module Data.These.Extra
data These a b

-- | A data type that represents either a value of type <tt>this</tt>, or a
--   value of type <tt>that</tt>, or both. data These this that = This this
--   | That that | These this that deriving (Eq,Ord, Read, Show)
--   
--   Constructor function, from Maybes
aThese :: Maybe a -> Maybe b -> These a b
both :: Semigroup a => (t1 -> a) -> (t2 -> a) -> These t1 t2 -> a
hasThis :: These a b -> Bool
hasThat :: These a1 a -> Bool
fromThis :: These c b -> c
fromThat :: These a1 c -> c

module ZM.BLOB.BLOBList
data BLOB encoding
BLOB :: encoding -> [Word8] -> BLOB encoding
[encoding] :: BLOB encoding -> encoding
[content] :: BLOB encoding -> [Word8]
instance GHC.Read.Read encoding => GHC.Read.Read (ZM.BLOB.BLOBList.BLOB encoding)
instance GHC.Show.Show encoding => GHC.Show.Show (ZM.BLOB.BLOBList.BLOB encoding)

module ZM.Type.Bit

-- | A Bit
data Bit
V0 :: Bit
V1 :: Bit
instance Data.Model.Class.Model ZM.Type.Bit.Bit
instance Flat.Class.Flat ZM.Type.Bit.Bit
instance GHC.Generics.Generic ZM.Type.Bit.Bit
instance GHC.Show.Show ZM.Type.Bit.Bit
instance GHC.Classes.Ord ZM.Type.Bit.Bit
instance GHC.Classes.Eq ZM.Type.Bit.Bit

module ZM.Type.Bits11
data Bits11
Bits11 :: Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bits11
[bit0] :: Bits11 -> Bit
[bit1] :: Bits11 -> Bit
[bit2] :: Bits11 -> Bit
[bit3] :: Bits11 -> Bit
[bit4] :: Bits11 -> Bit
[bit5] :: Bits11 -> Bit
[bit6] :: Bits11 -> Bit
[bit7] :: Bits11 -> Bit
[bit8] :: Bits11 -> Bit
[bit9] :: Bits11 -> Bit
[bit10] :: Bits11 -> Bit
instance Data.Model.Class.Model ZM.Type.Bits11.Bits11
instance Flat.Class.Flat ZM.Type.Bits11.Bits11
instance GHC.Generics.Generic ZM.Type.Bits11.Bits11
instance GHC.Show.Show ZM.Type.Bits11.Bits11
instance GHC.Classes.Ord ZM.Type.Bits11.Bits11
instance GHC.Classes.Eq ZM.Type.Bits11.Bits11

module ZM.Type.Bits23
data Bits23
Bits23 :: Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bits23
[bit0] :: Bits23 -> Bit
[bit1] :: Bits23 -> Bit
[bit2] :: Bits23 -> Bit
[bit3] :: Bits23 -> Bit
[bit4] :: Bits23 -> Bit
[bit5] :: Bits23 -> Bit
[bit6] :: Bits23 -> Bit
[bit7] :: Bits23 -> Bit
[bit8] :: Bits23 -> Bit
[bit9] :: Bits23 -> Bit
[bit10] :: Bits23 -> Bit
[bit11] :: Bits23 -> Bit
[bit12] :: Bits23 -> Bit
[bit13] :: Bits23 -> Bit
[bit14] :: Bits23 -> Bit
[bit15] :: Bits23 -> Bit
[bit16] :: Bits23 -> Bit
[bit17] :: Bits23 -> Bit
[bit18] :: Bits23 -> Bit
[bit19] :: Bits23 -> Bit
[bit20] :: Bits23 -> Bit
[bit21] :: Bits23 -> Bit
[bit22] :: Bits23 -> Bit
instance Flat.Class.Flat ZM.Type.Bits23.Bits23
instance Data.Model.Class.Model ZM.Type.Bits23.Bits23
instance GHC.Generics.Generic ZM.Type.Bits23.Bits23
instance GHC.Show.Show ZM.Type.Bits23.Bits23
instance GHC.Classes.Ord ZM.Type.Bits23.Bits23
instance GHC.Classes.Eq ZM.Type.Bits23.Bits23

module ZM.Type.Bits52
data Bits52
Bits52 :: Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bits52
[bit0] :: Bits52 -> Bit
[bit1] :: Bits52 -> Bit
[bit2] :: Bits52 -> Bit
[bit3] :: Bits52 -> Bit
[bit4] :: Bits52 -> Bit
[bit5] :: Bits52 -> Bit
[bit6] :: Bits52 -> Bit
[bit7] :: Bits52 -> Bit
[bit8] :: Bits52 -> Bit
[bit9] :: Bits52 -> Bit
[bit10] :: Bits52 -> Bit
[bit11] :: Bits52 -> Bit
[bit12] :: Bits52 -> Bit
[bit13] :: Bits52 -> Bit
[bit14] :: Bits52 -> Bit
[bit15] :: Bits52 -> Bit
[bit16] :: Bits52 -> Bit
[bit17] :: Bits52 -> Bit
[bit18] :: Bits52 -> Bit
[bit19] :: Bits52 -> Bit
[bit20] :: Bits52 -> Bit
[bit21] :: Bits52 -> Bit
[bit22] :: Bits52 -> Bit
[bit23] :: Bits52 -> Bit
[bit24] :: Bits52 -> Bit
[bit25] :: Bits52 -> Bit
[bit26] :: Bits52 -> Bit
[bit27] :: Bits52 -> Bit
[bit28] :: Bits52 -> Bit
[bit29] :: Bits52 -> Bit
[bit30] :: Bits52 -> Bit
[bit31] :: Bits52 -> Bit
[bit32] :: Bits52 -> Bit
[bit33] :: Bits52 -> Bit
[bit34] :: Bits52 -> Bit
[bit35] :: Bits52 -> Bit
[bit36] :: Bits52 -> Bit
[bit37] :: Bits52 -> Bit
[bit38] :: Bits52 -> Bit
[bit39] :: Bits52 -> Bit
[bit40] :: Bits52 -> Bit
[bit41] :: Bits52 -> Bit
[bit42] :: Bits52 -> Bit
[bit43] :: Bits52 -> Bit
[bit44] :: Bits52 -> Bit
[bit45] :: Bits52 -> Bit
[bit46] :: Bits52 -> Bit
[bit47] :: Bits52 -> Bit
[bit48] :: Bits52 -> Bit
[bit49] :: Bits52 -> Bit
[bit50] :: Bits52 -> Bit
[bit51] :: Bits52 -> Bit
instance Data.Model.Class.Model ZM.Type.Bits52.Bits52
instance Flat.Class.Flat ZM.Type.Bits52.Bits52
instance GHC.Generics.Generic ZM.Type.Bits52.Bits52
instance GHC.Show.Show ZM.Type.Bits52.Bits52
instance GHC.Classes.Ord ZM.Type.Bits52.Bits52
instance GHC.Classes.Eq ZM.Type.Bits52.Bits52

module ZM.Type.Bits8
data Bits8
Bits8 :: Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bits8
[bit0] :: Bits8 -> Bit
[bit1] :: Bits8 -> Bit
[bit2] :: Bits8 -> Bit
[bit3] :: Bits8 -> Bit
[bit4] :: Bits8 -> Bit
[bit5] :: Bits8 -> Bit
[bit6] :: Bits8 -> Bit
[bit7] :: Bits8 -> Bit
instance Data.Model.Class.Model ZM.Type.Bits8.Bits8
instance Flat.Class.Flat ZM.Type.Bits8.Bits8
instance GHC.Generics.Generic ZM.Type.Bits8.Bits8
instance GHC.Show.Show ZM.Type.Bits8.Bits8
instance GHC.Classes.Ord ZM.Type.Bits8.Bits8
instance GHC.Classes.Eq ZM.Type.Bits8.Bits8


-- | Generate the large constructor trees of some primitive types
--   (Array,Word8,Word7)
module ZM.Type.Generate

-- | Constructor Tree for: data Array a = A0 | A1 a (Array a) .. | A255 a
--   .. a (Array a)
arrayCT :: Maybe (ConTree String (TypeRef QualName))

-- | Constructor Tree for: data Word8 = V0 | V1 .. | V255
word8CT :: Maybe (ConTree String ref)

-- | Constructor Tree for: data Word7 = V0 | V1 .. | V127
word7CT :: Maybe (ConTree String ref)
instance GHC.Show.Show ZM.Type.Generate.Cons

module ZM.Type.List

-- | A list
data List a
Nil :: List a
Cons :: a -> List a -> List a
instance Flat.Class.Flat a => Flat.Class.Flat (ZM.Type.List.List a)
instance Data.Traversable.Traversable ZM.Type.List.List
instance Data.Foldable.Foldable ZM.Type.List.List
instance GHC.Base.Functor ZM.Type.List.List
instance GHC.Generics.Generic (ZM.Type.List.List a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (ZM.Type.List.List a)
instance GHC.Show.Show a => GHC.Show.Show (ZM.Type.List.List a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (ZM.Type.List.List a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (ZM.Type.List.List a)
instance Data.Model.Class.Model a => Data.Model.Class.Model (ZM.Type.List.List a)

module ZM.Type.NonEmptyList

-- | A list that contains at least one element
data NonEmptyList a
Elem :: a -> NonEmptyList a
Cons :: a -> NonEmptyList a -> NonEmptyList a

-- | Convert a list to a <a>NonEmptyList</a>, returns an error if the list
--   is empty
nonEmptyList :: [a] -> NonEmptyList a
instance Flat.Class.Flat a => Flat.Class.Flat (ZM.Type.NonEmptyList.NonEmptyList a)
instance Data.Traversable.Traversable ZM.Type.NonEmptyList.NonEmptyList
instance Data.Foldable.Foldable ZM.Type.NonEmptyList.NonEmptyList
instance GHC.Base.Functor ZM.Type.NonEmptyList.NonEmptyList
instance GHC.Generics.Generic (ZM.Type.NonEmptyList.NonEmptyList a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (ZM.Type.NonEmptyList.NonEmptyList a)
instance GHC.Show.Show a => GHC.Show.Show (ZM.Type.NonEmptyList.NonEmptyList a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (ZM.Type.NonEmptyList.NonEmptyList a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (ZM.Type.NonEmptyList.NonEmptyList a)
instance Data.Model.Class.Model a => Data.Model.Class.Model (ZM.Type.NonEmptyList.NonEmptyList a)

module ZM.Type.Repo
data AllKnown a
AllKnown :: AllKnown a
data Record a
Record :: a -> Record a
data Solve ref to
Solve :: ref -> Solve ref to
instance Flat.Class.Flat (ZM.Type.Repo.AllKnown a)
instance GHC.Generics.Generic (ZM.Type.Repo.AllKnown a)
instance GHC.Show.Show (ZM.Type.Repo.AllKnown a)
instance GHC.Classes.Ord (ZM.Type.Repo.AllKnown a)
instance GHC.Classes.Eq (ZM.Type.Repo.AllKnown a)
instance Flat.Class.Flat a => Flat.Class.Flat (ZM.Type.Repo.Record a)
instance GHC.Generics.Generic (ZM.Type.Repo.Record a)
instance GHC.Show.Show a => GHC.Show.Show (ZM.Type.Repo.Record a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (ZM.Type.Repo.Record a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (ZM.Type.Repo.Record a)
instance Flat.Class.Flat ref => Flat.Class.Flat (ZM.Type.Repo.Solve ref to)
instance GHC.Generics.Generic (ZM.Type.Repo.Solve ref to)
instance GHC.Show.Show ref => GHC.Show.Show (ZM.Type.Repo.Solve ref to)
instance GHC.Classes.Ord ref => GHC.Classes.Ord (ZM.Type.Repo.Solve ref to)
instance GHC.Classes.Eq ref => GHC.Classes.Eq (ZM.Type.Repo.Solve ref to)
instance (Data.Model.Class.Model a, Data.Model.Class.Model b) => Data.Model.Class.Model (ZM.Type.Repo.Solve a b)
instance Data.Model.Class.Model a => Data.Model.Class.Model (ZM.Type.Repo.Record a)
instance Data.Model.Class.Model a => Data.Model.Class.Model (ZM.Type.Repo.AllKnown a)

module ZM.Type.Tuples
data Tuple2 a b
Tuple2 :: a -> b -> Tuple2 a b
data Tuple3 a b c
Tuple3 :: a -> b -> c -> Tuple3 a b c
data Tuple4 a b c d
Tuple4 :: a -> b -> c -> d -> Tuple4 a b c d
data Tuple5 a1 a2 a3 a4 a5
Tuple5 :: a1 -> a2 -> a3 -> a4 -> a5 -> Tuple5 a1 a2 a3 a4 a5
data Tuple6 a1 a2 a3 a4 a5 a6
Tuple6 :: a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> Tuple6 a1 a2 a3 a4 a5 a6
data Tuple7 a1 a2 a3 a4 a5 a6 a7
Tuple7 :: a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> Tuple7 a1 a2 a3 a4 a5 a6 a7
data Tuple8 a1 a2 a3 a4 a5 a6 a7 a8
Tuple8 :: a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> Tuple8 a1 a2 a3 a4 a5 a6 a7 a8
data Tuple9 a1 a2 a3 a4 a5 a6 a7 a8 a9
Tuple9 :: a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> a9 -> Tuple9 a1 a2 a3 a4 a5 a6 a7 a8 a9
instance GHC.Generics.Generic (ZM.Type.Tuples.Tuple2 a b)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (ZM.Type.Tuples.Tuple2 a b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (ZM.Type.Tuples.Tuple2 a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (ZM.Type.Tuples.Tuple2 a b)
instance GHC.Generics.Generic (ZM.Type.Tuples.Tuple3 a b c)
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c) => GHC.Show.Show (ZM.Type.Tuples.Tuple3 a b c)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c) => GHC.Classes.Ord (ZM.Type.Tuples.Tuple3 a b c)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c) => GHC.Classes.Eq (ZM.Type.Tuples.Tuple3 a b c)
instance GHC.Generics.Generic (ZM.Type.Tuples.Tuple4 a b c d)
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d) => GHC.Show.Show (ZM.Type.Tuples.Tuple4 a b c d)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d) => GHC.Classes.Ord (ZM.Type.Tuples.Tuple4 a b c d)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d) => GHC.Classes.Eq (ZM.Type.Tuples.Tuple4 a b c d)
instance GHC.Generics.Generic (ZM.Type.Tuples.Tuple5 a1 a2 a3 a4 a5)
instance (GHC.Show.Show a1, GHC.Show.Show a2, GHC.Show.Show a3, GHC.Show.Show a4, GHC.Show.Show a5) => GHC.Show.Show (ZM.Type.Tuples.Tuple5 a1 a2 a3 a4 a5)
instance (GHC.Classes.Ord a1, GHC.Classes.Ord a2, GHC.Classes.Ord a3, GHC.Classes.Ord a4, GHC.Classes.Ord a5) => GHC.Classes.Ord (ZM.Type.Tuples.Tuple5 a1 a2 a3 a4 a5)
instance (GHC.Classes.Eq a1, GHC.Classes.Eq a2, GHC.Classes.Eq a3, GHC.Classes.Eq a4, GHC.Classes.Eq a5) => GHC.Classes.Eq (ZM.Type.Tuples.Tuple5 a1 a2 a3 a4 a5)
instance GHC.Generics.Generic (ZM.Type.Tuples.Tuple6 a1 a2 a3 a4 a5 a6)
instance (GHC.Show.Show a1, GHC.Show.Show a2, GHC.Show.Show a3, GHC.Show.Show a4, GHC.Show.Show a5, GHC.Show.Show a6) => GHC.Show.Show (ZM.Type.Tuples.Tuple6 a1 a2 a3 a4 a5 a6)
instance (GHC.Classes.Ord a1, GHC.Classes.Ord a2, GHC.Classes.Ord a3, GHC.Classes.Ord a4, GHC.Classes.Ord a5, GHC.Classes.Ord a6) => GHC.Classes.Ord (ZM.Type.Tuples.Tuple6 a1 a2 a3 a4 a5 a6)
instance (GHC.Classes.Eq a1, GHC.Classes.Eq a2, GHC.Classes.Eq a3, GHC.Classes.Eq a4, GHC.Classes.Eq a5, GHC.Classes.Eq a6) => GHC.Classes.Eq (ZM.Type.Tuples.Tuple6 a1 a2 a3 a4 a5 a6)
instance GHC.Generics.Generic (ZM.Type.Tuples.Tuple7 a1 a2 a3 a4 a5 a6 a7)
instance (GHC.Show.Show a1, GHC.Show.Show a2, GHC.Show.Show a3, GHC.Show.Show a4, GHC.Show.Show a5, GHC.Show.Show a6, GHC.Show.Show a7) => GHC.Show.Show (ZM.Type.Tuples.Tuple7 a1 a2 a3 a4 a5 a6 a7)
instance (GHC.Classes.Ord a1, GHC.Classes.Ord a2, GHC.Classes.Ord a3, GHC.Classes.Ord a4, GHC.Classes.Ord a5, GHC.Classes.Ord a6, GHC.Classes.Ord a7) => GHC.Classes.Ord (ZM.Type.Tuples.Tuple7 a1 a2 a3 a4 a5 a6 a7)
instance (GHC.Classes.Eq a1, GHC.Classes.Eq a2, GHC.Classes.Eq a3, GHC.Classes.Eq a4, GHC.Classes.Eq a5, GHC.Classes.Eq a6, GHC.Classes.Eq a7) => GHC.Classes.Eq (ZM.Type.Tuples.Tuple7 a1 a2 a3 a4 a5 a6 a7)
instance GHC.Generics.Generic (ZM.Type.Tuples.Tuple8 a1 a2 a3 a4 a5 a6 a7 a8)
instance (GHC.Show.Show a1, GHC.Show.Show a2, GHC.Show.Show a3, GHC.Show.Show a4, GHC.Show.Show a5, GHC.Show.Show a6, GHC.Show.Show a7, GHC.Show.Show a8) => GHC.Show.Show (ZM.Type.Tuples.Tuple8 a1 a2 a3 a4 a5 a6 a7 a8)
instance (GHC.Classes.Ord a1, GHC.Classes.Ord a2, GHC.Classes.Ord a3, GHC.Classes.Ord a4, GHC.Classes.Ord a5, GHC.Classes.Ord a6, GHC.Classes.Ord a7, GHC.Classes.Ord a8) => GHC.Classes.Ord (ZM.Type.Tuples.Tuple8 a1 a2 a3 a4 a5 a6 a7 a8)
instance (GHC.Classes.Eq a1, GHC.Classes.Eq a2, GHC.Classes.Eq a3, GHC.Classes.Eq a4, GHC.Classes.Eq a5, GHC.Classes.Eq a6, GHC.Classes.Eq a7, GHC.Classes.Eq a8) => GHC.Classes.Eq (ZM.Type.Tuples.Tuple8 a1 a2 a3 a4 a5 a6 a7 a8)
instance GHC.Generics.Generic (ZM.Type.Tuples.Tuple9 a1 a2 a3 a4 a5 a6 a7 a8 a9)
instance (GHC.Show.Show a1, GHC.Show.Show a2, GHC.Show.Show a3, GHC.Show.Show a4, GHC.Show.Show a5, GHC.Show.Show a6, GHC.Show.Show a7, GHC.Show.Show a8, GHC.Show.Show a9) => GHC.Show.Show (ZM.Type.Tuples.Tuple9 a1 a2 a3 a4 a5 a6 a7 a8 a9)
instance (GHC.Classes.Ord a1, GHC.Classes.Ord a2, GHC.Classes.Ord a3, GHC.Classes.Ord a4, GHC.Classes.Ord a5, GHC.Classes.Ord a6, GHC.Classes.Ord a7, GHC.Classes.Ord a8, GHC.Classes.Ord a9) => GHC.Classes.Ord (ZM.Type.Tuples.Tuple9 a1 a2 a3 a4 a5 a6 a7 a8 a9)
instance (GHC.Classes.Eq a1, GHC.Classes.Eq a2, GHC.Classes.Eq a3, GHC.Classes.Eq a4, GHC.Classes.Eq a5, GHC.Classes.Eq a6, GHC.Classes.Eq a7, GHC.Classes.Eq a8, GHC.Classes.Eq a9) => GHC.Classes.Eq (ZM.Type.Tuples.Tuple9 a1 a2 a3 a4 a5 a6 a7 a8 a9)
instance (Data.Model.Class.Model a1, Data.Model.Class.Model a2, Data.Model.Class.Model a3, Data.Model.Class.Model a4, Data.Model.Class.Model a5, Data.Model.Class.Model a6, Data.Model.Class.Model a7, Data.Model.Class.Model a8, Data.Model.Class.Model a9) => Data.Model.Class.Model (ZM.Type.Tuples.Tuple9 a1 a2 a3 a4 a5 a6 a7 a8 a9)
instance (Data.Model.Class.Model a1, Data.Model.Class.Model a2, Data.Model.Class.Model a3, Data.Model.Class.Model a4, Data.Model.Class.Model a5, Data.Model.Class.Model a6, Data.Model.Class.Model a7, Data.Model.Class.Model a8) => Data.Model.Class.Model (ZM.Type.Tuples.Tuple8 a1 a2 a3 a4 a5 a6 a7 a8)
instance (Data.Model.Class.Model a1, Data.Model.Class.Model a2, Data.Model.Class.Model a3, Data.Model.Class.Model a4, Data.Model.Class.Model a5, Data.Model.Class.Model a6, Data.Model.Class.Model a7) => Data.Model.Class.Model (ZM.Type.Tuples.Tuple7 a1 a2 a3 a4 a5 a6 a7)
instance (Data.Model.Class.Model a1, Data.Model.Class.Model a2, Data.Model.Class.Model a3, Data.Model.Class.Model a4, Data.Model.Class.Model a5, Data.Model.Class.Model a6) => Data.Model.Class.Model (ZM.Type.Tuples.Tuple6 a1 a2 a3 a4 a5 a6)
instance (Data.Model.Class.Model a1, Data.Model.Class.Model a2, Data.Model.Class.Model a3, Data.Model.Class.Model a4, Data.Model.Class.Model a5) => Data.Model.Class.Model (ZM.Type.Tuples.Tuple5 a1 a2 a3 a4 a5)
instance (Data.Model.Class.Model a, Data.Model.Class.Model b, Data.Model.Class.Model c, Data.Model.Class.Model d) => Data.Model.Class.Model (ZM.Type.Tuples.Tuple4 a b c d)
instance (Data.Model.Class.Model a, Data.Model.Class.Model b, Data.Model.Class.Model c) => Data.Model.Class.Model (ZM.Type.Tuples.Tuple3 a b c)
instance (Data.Model.Class.Model a, Data.Model.Class.Model b) => Data.Model.Class.Model (ZM.Type.Tuples.Tuple2 a b)

module ZM.Type.Map

-- | A Map is represented as a list of key and value couples
data Map a b
instance GHC.Generics.Generic (ZM.Type.Map.Map a b)
instance (Data.Model.Class.Model a, Data.Model.Class.Model b) => Data.Model.Class.Model (ZM.Type.Map.Map a b)

module ZM.Type.Unit

-- | The Unit type
data Unit
Unit :: Unit
instance Data.Model.Class.Model ZM.Type.Unit.Unit
instance GHC.Generics.Generic ZM.Type.Unit.Unit
instance GHC.Show.Show ZM.Type.Unit.Unit
instance GHC.Classes.Ord ZM.Type.Unit.Unit
instance GHC.Classes.Eq ZM.Type.Unit.Unit

module ZM.Type.Words
data Sign
Positive :: Sign
Negative :: Sign

-- | A 7 bits unsigned integer data Word7 = V0 .. V127
data Word7
Word7 :: Word8 -> Word7

-- | An unsigned integer of arbitrary length encoded as a non empty list of
--   Word7 words with least significant word first and, inside each word,
--   most significant bit first.
--   
--   Example: 3450 :: Word
--   
--   Binary representation: 0000110101111010
--   
--   Split in 7bits groups: 0011010(==26 decimal) 1111010(==122 decimal)
--   
--   Build a non-empty list whose elements are the groups in reverse order:
--   Word (Cons V122 (Elem V26))
--   
--   So Least Significant Byte first with Most Significant Bit first in
--   every 7 bits group.
--   
--   <ul>
--   <li>- BUG: MostSignificantFirst is useless, Word7 already has an
--   order.</li>
--   </ul>
data Word
Word :: LeastSignificantFirst (NonEmptyList (MostSignificantFirst Word7)) -> Word

-- | An 8 bits unsigned integer data Word8 = V0 | V1 .. | V255
data Word8
Word8 :: Word8 -> Word8
data Word16
Word16 :: Word -> Word16
data Word32
Word32 :: Word -> Word32
data Word64
Word64 :: Word -> Word64
data Int
Int :: ZigZag Word -> Int
data Int8
Int8 :: ZigZag Word8 -> Int8
data Int16
Int16 :: ZigZag Word16 -> Int16
data Int32
Int32 :: ZigZag Word32 -> Int32
data Int64
Int64 :: ZigZag Word64 -> Int64

-- | ZigZag encoding, map signed integers to unsigned integers Positive
--   integers are mapped to even unsigned values, negative integers to odd
--   values: 0 -&gt; 0, -1 -&gt; 1, 1 -&gt; 2, -2 -&gt; 3, 2 -&gt; 4 ...
data ZigZag a
ZigZag :: a -> ZigZag a
data MostSignificantFirst a
MostSignificantFirst :: a -> MostSignificantFirst a
data LeastSignificantFirst a
LeastSignificantFirst :: a -> LeastSignificantFirst a
instance GHC.Generics.Generic ZM.Type.Words.Word7
instance GHC.Show.Show ZM.Type.Words.Word7
instance GHC.Read.Read ZM.Type.Words.Word7
instance GHC.Classes.Ord ZM.Type.Words.Word7
instance GHC.Classes.Eq ZM.Type.Words.Word7
instance GHC.Generics.Generic ZM.Type.Words.Word8
instance GHC.Show.Show ZM.Type.Words.Word8
instance GHC.Read.Read ZM.Type.Words.Word8
instance GHC.Classes.Ord ZM.Type.Words.Word8
instance GHC.Classes.Eq ZM.Type.Words.Word8
instance Flat.Class.Flat a => Flat.Class.Flat (ZM.Type.Words.ZigZag a)
instance GHC.Generics.Generic (ZM.Type.Words.ZigZag a)
instance GHC.Show.Show a => GHC.Show.Show (ZM.Type.Words.ZigZag a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (ZM.Type.Words.ZigZag a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (ZM.Type.Words.ZigZag a)
instance Data.Model.Class.Model ZM.Type.Words.Int8
instance GHC.Generics.Generic ZM.Type.Words.Int8
instance GHC.Show.Show ZM.Type.Words.Int8
instance GHC.Classes.Ord ZM.Type.Words.Int8
instance GHC.Classes.Eq ZM.Type.Words.Int8
instance Flat.Class.Flat a => Flat.Class.Flat (ZM.Type.Words.LeastSignificantFirst a)
instance GHC.Generics.Generic (ZM.Type.Words.LeastSignificantFirst a)
instance GHC.Show.Show a => GHC.Show.Show (ZM.Type.Words.LeastSignificantFirst a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (ZM.Type.Words.LeastSignificantFirst a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (ZM.Type.Words.LeastSignificantFirst a)
instance Flat.Class.Flat a => Flat.Class.Flat (ZM.Type.Words.MostSignificantFirst a)
instance GHC.Generics.Generic (ZM.Type.Words.MostSignificantFirst a)
instance GHC.Show.Show a => GHC.Show.Show (ZM.Type.Words.MostSignificantFirst a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (ZM.Type.Words.MostSignificantFirst a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (ZM.Type.Words.MostSignificantFirst a)
instance Data.Model.Class.Model ZM.Type.Words.Word
instance GHC.Generics.Generic ZM.Type.Words.Word
instance GHC.Show.Show ZM.Type.Words.Word
instance GHC.Classes.Ord ZM.Type.Words.Word
instance GHC.Classes.Eq ZM.Type.Words.Word
instance Data.Model.Class.Model ZM.Type.Words.Int
instance GHC.Generics.Generic ZM.Type.Words.Int
instance GHC.Show.Show ZM.Type.Words.Int
instance GHC.Classes.Ord ZM.Type.Words.Int
instance GHC.Classes.Eq ZM.Type.Words.Int
instance Data.Model.Class.Model ZM.Type.Words.Word64
instance GHC.Generics.Generic ZM.Type.Words.Word64
instance GHC.Show.Show ZM.Type.Words.Word64
instance GHC.Classes.Ord ZM.Type.Words.Word64
instance GHC.Classes.Eq ZM.Type.Words.Word64
instance Data.Model.Class.Model ZM.Type.Words.Int64
instance GHC.Generics.Generic ZM.Type.Words.Int64
instance GHC.Show.Show ZM.Type.Words.Int64
instance GHC.Classes.Ord ZM.Type.Words.Int64
instance GHC.Classes.Eq ZM.Type.Words.Int64
instance Data.Model.Class.Model ZM.Type.Words.Word32
instance GHC.Generics.Generic ZM.Type.Words.Word32
instance GHC.Show.Show ZM.Type.Words.Word32
instance GHC.Classes.Ord ZM.Type.Words.Word32
instance GHC.Classes.Eq ZM.Type.Words.Word32
instance Data.Model.Class.Model ZM.Type.Words.Int32
instance GHC.Generics.Generic ZM.Type.Words.Int32
instance GHC.Show.Show ZM.Type.Words.Int32
instance GHC.Classes.Ord ZM.Type.Words.Int32
instance GHC.Classes.Eq ZM.Type.Words.Int32
instance Data.Model.Class.Model ZM.Type.Words.Word16
instance GHC.Generics.Generic ZM.Type.Words.Word16
instance GHC.Show.Show ZM.Type.Words.Word16
instance GHC.Classes.Ord ZM.Type.Words.Word16
instance GHC.Classes.Eq ZM.Type.Words.Word16
instance Data.Model.Class.Model ZM.Type.Words.Int16
instance GHC.Generics.Generic ZM.Type.Words.Int16
instance GHC.Show.Show ZM.Type.Words.Int16
instance GHC.Classes.Ord ZM.Type.Words.Int16
instance GHC.Classes.Eq ZM.Type.Words.Int16
instance Flat.Class.Flat ZM.Type.Words.Sign
instance Data.Model.Class.Model ZM.Type.Words.Sign
instance GHC.Generics.Generic ZM.Type.Words.Sign
instance GHC.Show.Show ZM.Type.Words.Sign
instance GHC.Classes.Ord ZM.Type.Words.Sign
instance GHC.Classes.Eq ZM.Type.Words.Sign
instance Data.Model.Class.Model a => Data.Model.Class.Model (ZM.Type.Words.MostSignificantFirst a)
instance Data.Model.Class.Model a => Data.Model.Class.Model (ZM.Type.Words.LeastSignificantFirst a)
instance Data.Model.Class.Model a => Data.Model.Class.Model (ZM.Type.Words.ZigZag a)
instance Data.Model.Class.Model ZM.Type.Words.Word8
instance Data.Model.Class.Model ZM.Type.Words.Word7

module ZM.Type.Prims
instance Data.Model.Class.Model GHC.Types.Word
instance Data.Model.Class.Model GHC.Types.Int
instance Data.Model.Class.Model GHC.Word.Word8
instance Data.Model.Class.Model GHC.Word.Word16
instance Data.Model.Class.Model GHC.Word.Word32
instance Data.Model.Class.Model GHC.Word.Word64
instance Data.Model.Class.Model GHC.Int.Int8
instance Data.Model.Class.Model GHC.Int.Int16
instance Data.Model.Class.Model GHC.Int.Int32
instance Data.Model.Class.Model GHC.Int.Int64
instance Data.Model.Class.Model GHC.Integer.Type.Integer
instance Data.Model.Class.Model GHC.Natural.Natural

module ZM.Type.Array

-- | An Array.
--   
--   A sequence of sequences of up to to 255 values. <tt> Array a = A0 | A1
--   a (Array a) | A2 a a (Array a) ... | A255 a ... (Array a) </tt>
data Array a
Array :: [a] -> Array a

-- | A byte-aligned byte array To encode and decode efficiently an Array of
--   Bytes, we pre-align it to the nearest byte border.
data Bytes
Bytes :: PreAligned (Array Word8) -> Bytes
instance Data.Foldable.Foldable ZM.Type.Array.Array
instance GHC.Show.Show a => GHC.Show.Show (ZM.Type.Array.Array a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (ZM.Type.Array.Array a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (ZM.Type.Array.Array a)
instance Data.Model.Class.Model ZM.Type.Array.Bytes
instance GHC.Generics.Generic ZM.Type.Array.Bytes
instance Data.Model.Class.Model a => Data.Model.Class.Model (ZM.Type.Array.Array a)
instance Flat.Class.Flat a => Flat.Class.Flat (ZM.Type.Array.Array a)
instance Data.Model.Class.Model Flat.Filler.Filler
instance Data.Model.Class.Model a => Data.Model.Class.Model (Flat.Filler.PreAligned a)


-- | Binary Large OBjects (BLOBs)
module ZM.Type.BLOB

-- | A BLOB is binary value encoded according to a specified encoding (e.g.
--   UTF8)
data BLOB encoding
BLOB :: encoding -> Bytes -> BLOB encoding
[encoding] :: BLOB encoding -> encoding
[content] :: BLOB encoding -> Bytes

-- | UTF-8 Encoding
data UTF8Encoding
UTF8Encoding :: UTF8Encoding

-- | UTF-16 Little Endian Encoding
data UTF16LEEncoding
UTF16LEEncoding :: UTF16LEEncoding

-- | Flat encoding
data FlatEncoding
FlatEncoding :: FlatEncoding

-- | Unspecified encoding
data NoEncoding
NoEncoding :: NoEncoding
instance GHC.Generics.Generic (ZM.Type.BLOB.BLOB encoding)
instance Data.Model.Class.Model ZM.Type.BLOB.UTF8Encoding
instance Flat.Class.Flat ZM.Type.BLOB.UTF8Encoding
instance GHC.Generics.Generic ZM.Type.BLOB.UTF8Encoding
instance Control.DeepSeq.NFData ZM.Type.BLOB.UTF8Encoding
instance GHC.Read.Read ZM.Type.BLOB.UTF8Encoding
instance GHC.Show.Show ZM.Type.BLOB.UTF8Encoding
instance GHC.Classes.Ord ZM.Type.BLOB.UTF8Encoding
instance GHC.Classes.Eq ZM.Type.BLOB.UTF8Encoding
instance Data.Model.Class.Model ZM.Type.BLOB.UTF16LEEncoding
instance Flat.Class.Flat ZM.Type.BLOB.UTF16LEEncoding
instance GHC.Generics.Generic ZM.Type.BLOB.UTF16LEEncoding
instance Control.DeepSeq.NFData ZM.Type.BLOB.UTF16LEEncoding
instance GHC.Read.Read ZM.Type.BLOB.UTF16LEEncoding
instance GHC.Show.Show ZM.Type.BLOB.UTF16LEEncoding
instance GHC.Classes.Ord ZM.Type.BLOB.UTF16LEEncoding
instance GHC.Classes.Eq ZM.Type.BLOB.UTF16LEEncoding
instance Data.Model.Class.Model ZM.Type.BLOB.FlatEncoding
instance Flat.Class.Flat ZM.Type.BLOB.FlatEncoding
instance GHC.Generics.Generic ZM.Type.BLOB.FlatEncoding
instance Control.DeepSeq.NFData ZM.Type.BLOB.FlatEncoding
instance GHC.Read.Read ZM.Type.BLOB.FlatEncoding
instance GHC.Show.Show ZM.Type.BLOB.FlatEncoding
instance GHC.Classes.Ord ZM.Type.BLOB.FlatEncoding
instance GHC.Classes.Eq ZM.Type.BLOB.FlatEncoding
instance Data.Model.Class.Model ZM.Type.BLOB.NoEncoding
instance Flat.Class.Flat ZM.Type.BLOB.NoEncoding
instance GHC.Generics.Generic ZM.Type.BLOB.NoEncoding
instance Control.DeepSeq.NFData ZM.Type.BLOB.NoEncoding
instance GHC.Read.Read ZM.Type.BLOB.NoEncoding
instance GHC.Show.Show ZM.Type.BLOB.NoEncoding
instance GHC.Classes.Ord ZM.Type.BLOB.NoEncoding
instance GHC.Classes.Eq ZM.Type.BLOB.NoEncoding
instance Data.Model.Class.Model encoding => Data.Model.Class.Model (ZM.Type.BLOB.BLOB encoding)

module ZM.Type.Float64

-- | An IEEE-754 Big Endian 64 bits Float
data IEEE_754_binary64
IEEE_754_binary64 :: Sign -> MostSignificantFirst Bits11 -> MostSignificantFirst Bits52 -> IEEE_754_binary64
[sign] :: IEEE_754_binary64 -> Sign
[exponent] :: IEEE_754_binary64 -> MostSignificantFirst Bits11
[fraction] :: IEEE_754_binary64 -> MostSignificantFirst Bits52
instance Data.Model.Class.Model ZM.Type.Float64.IEEE_754_binary64
instance GHC.Generics.Generic ZM.Type.Float64.IEEE_754_binary64
instance GHC.Show.Show ZM.Type.Float64.IEEE_754_binary64
instance GHC.Classes.Ord ZM.Type.Float64.IEEE_754_binary64
instance GHC.Classes.Eq ZM.Type.Float64.IEEE_754_binary64

module ZM.Type.Float32

-- | An IEEE-754 Big Endian 32 bits Float
data IEEE_754_binary32
IEEE_754_binary32 :: Sign -> MostSignificantFirst Bits8 -> MostSignificantFirst Bits23 -> IEEE_754_binary32
[sign] :: IEEE_754_binary32 -> Sign
[exponent] :: IEEE_754_binary32 -> MostSignificantFirst Bits8
[fraction] :: IEEE_754_binary32 -> MostSignificantFirst Bits23
instance Data.Model.Class.Model ZM.Type.Float32.IEEE_754_binary32
instance GHC.Generics.Generic ZM.Type.Float32.IEEE_754_binary32
instance GHC.Show.Show ZM.Type.Float32.IEEE_754_binary32
instance GHC.Classes.Ord ZM.Type.Float32.IEEE_754_binary32
instance GHC.Classes.Eq ZM.Type.Float32.IEEE_754_binary32

module ZM.Type.Char

-- | A Unicode Char
data Char
Char :: Word32 -> Char
instance Data.Model.Class.Model ZM.Type.Char.Char
instance GHC.Generics.Generic ZM.Type.Char.Char
instance GHC.Show.Show ZM.Type.Char.Char
instance GHC.Classes.Ord ZM.Type.Char.Char
instance GHC.Classes.Eq ZM.Type.Char.Char


-- | Mapping of basic Haskell types to equivalent ZhengMing types (Char,
--   (), Words, Ints, Floats, Text, Tuples, List, Seq, Map)
module ZM.Model
instance Data.Model.Class.Model GHC.Types.Char
instance Data.Model.Class.Model ()
instance Data.Model.Class.Model GHC.Types.Float
instance Data.Model.Class.Model GHC.Types.Double
instance Data.Model.Class.Model a => Data.Model.Class.Model [a]
instance Data.Model.Class.Model a => Data.Model.Class.Model (Data.Sequence.Internal.Seq a)
instance (Data.Model.Class.Model a, Data.Model.Class.Model b) => Data.Model.Class.Model (Data.Map.Internal.Map a b)
instance Data.Model.Class.Model Data.ByteString.Internal.ByteString
instance Data.Model.Class.Model Data.ByteString.Lazy.Internal.ByteString
instance Data.Model.Class.Model Data.ByteString.Short.Internal.ShortByteString
instance Data.Model.Class.Model Data.Text.Internal.Text
instance Data.Model.Class.AsType (Type.Analyse.Typ Data.Text.Internal.Text)
instance Data.Model.Class.Model Flat.Instances.Text.UTF8Text
instance Data.Model.Class.AsType (Type.Analyse.Typ Flat.Instances.Text.UTF8Text)
instance Data.Model.Class.Model Flat.Instances.Text.UTF16Text
instance Data.Model.Class.AsType (Type.Analyse.Typ Flat.Instances.Text.UTF16Text)
instance (Data.Model.Class.Model a, Data.Model.Class.Model b) => Data.Model.Class.Model (a, b)
instance (Data.Model.Class.Model a, Data.Model.Class.Model b, Data.Model.Class.Model c) => Data.Model.Class.Model (a, b, c)
instance (Data.Model.Class.Model a, Data.Model.Class.Model b, Data.Model.Class.Model c, Data.Model.Class.Model d) => Data.Model.Class.Model (a, b, c, d)
instance (Data.Model.Class.Model a1, Data.Model.Class.Model a2, Data.Model.Class.Model a3, Data.Model.Class.Model a4, Data.Model.Class.Model a5) => Data.Model.Class.Model (a1, a2, a3, a4, a5)
instance (Data.Model.Class.Model a1, Data.Model.Class.Model a2, Data.Model.Class.Model a3, Data.Model.Class.Model a4, Data.Model.Class.Model a5, Data.Model.Class.Model a6) => Data.Model.Class.Model (a1, a2, a3, a4, a5, a6)
instance (Data.Model.Class.Model a1, Data.Model.Class.Model a2, Data.Model.Class.Model a3, Data.Model.Class.Model a4, Data.Model.Class.Model a5, Data.Model.Class.Model a6, Data.Model.Class.Model a7) => Data.Model.Class.Model (a1, a2, a3, a4, a5, a6, a7)
instance (Data.Model.Class.Model a1, Data.Model.Class.Model a2, Data.Model.Class.Model a3, Data.Model.Class.Model a4, Data.Model.Class.Model a5, Data.Model.Class.Model a6, Data.Model.Class.Model a7, Data.Model.Class.Model a8) => Data.Model.Class.Model (a1, a2, a3, a4, a5, a6, a7, a8)
instance (Data.Model.Class.Model a1, Data.Model.Class.Model a2, Data.Model.Class.Model a3, Data.Model.Class.Model a4, Data.Model.Class.Model a5, Data.Model.Class.Model a6, Data.Model.Class.Model a7, Data.Model.Class.Model a8, Data.Model.Class.Model a9) => Data.Model.Class.Model (a1, a2, a3, a4, a5, a6, a7, a8, a9)

module ZM.Type.String
data String
String :: [Char] -> String
instance Control.DeepSeq.NFData ZM.Type.String.String
instance Data.Model.Class.Model ZM.Type.String.String
instance Flat.Class.Flat ZM.Type.String.String
instance GHC.Generics.Generic ZM.Type.String.String
instance GHC.Show.Show ZM.Type.String.String
instance GHC.Classes.Ord ZM.Type.String.String
instance GHC.Classes.Eq ZM.Type.String.String

module ZM.Types

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <a>id</a>
--   <a>to</a> . <a>from</a> ≡ <a>id</a>
--   </pre>
class Generic a where {
    
    -- | Generic representation type
    type family Rep a :: Type -> Type;
}

-- | Convert from the datatype to its representation
from :: Generic a => a -> Rep a x

-- | Convert from the representation to the datatype
to :: Generic a => Rep a x -> a

-- | Representable types of kind <tt>* -&gt; *</tt> (or kind <tt>k -&gt;
--   *</tt>, when <tt>PolyKinds</tt> is enabled). This class is derivable
--   in GHC with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic1</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from1</a> . <a>to1</a> ≡ <a>id</a>
--   <a>to1</a> . <a>from1</a> ≡ <a>id</a>
--   </pre>
class Generic1 (f :: k -> Type) where {
    
    -- | Generic representation type
    type family Rep1 (f :: k -> Type) :: k -> Type;
}

-- | Convert from the datatype to its representation
from1 :: forall (a :: k). Generic1 f => f a -> Rep1 f a

-- | Convert from the representation to the datatype
to1 :: forall (a :: k). Generic1 f => Rep1 f a -> f a

-- | Class for datatypes that represent datatypes
class Datatype (d :: k)

-- | The name of the datatype (unqualified)
datatypeName :: forall k1 t (f :: k1 -> Type) (a :: k1). Datatype d => t d f a -> [Char]

-- | The fully-qualified name of the module where the type is declared
moduleName :: forall k1 t (f :: k1 -> Type) (a :: k1). Datatype d => t d f a -> [Char]

-- | The package name of the module where the type is declared
packageName :: forall k1 t (f :: k1 -> Type) (a :: k1). Datatype d => t d f a -> [Char]

-- | Marks if the datatype is actually a newtype
isNewtype :: forall k1 t (f :: k1 -> Type) (a :: k1). Datatype d => t d f a -> Bool

-- | Class for datatypes that represent data constructors
class Constructor (c :: k)

-- | The name of the constructor
conName :: forall k1 t (f :: k1 -> Type) (a :: k1). Constructor c => t c f a -> [Char]

-- | The fixity of the constructor
conFixity :: forall k1 t (f :: k1 -> Type) (a :: k1). Constructor c => t c f a -> Fixity

-- | Marks if this constructor is a record
conIsRecord :: forall k1 t (f :: k1 -> Type) (a :: k1). Constructor c => t c f a -> Bool

-- | Class for datatypes that represent records
class Selector (s :: k)

-- | The name of the selector
selName :: forall k1 t (f :: k1 -> Type) (a :: k1). Selector s => t s f a -> [Char]

-- | The selector's unpackedness annotation (if any)
selSourceUnpackedness :: forall k1 t (f :: k1 -> Type) (a :: k1). Selector s => t s f a -> SourceUnpackedness

-- | The selector's strictness annotation (if any)
selSourceStrictness :: forall k1 t (f :: k1 -> Type) (a :: k1). Selector s => t s f a -> SourceStrictness

-- | The strictness that the compiler inferred for the selector
selDecidedStrictness :: forall k1 t (f :: k1 -> Type) (a :: k1). Selector s => t s f a -> DecidedStrictness

-- | Void: used for datatypes without constructors
data V1 (p :: k)

-- | Unit: used for constructors without arguments
data U1 (p :: k)
U1 :: U1 (p :: k)

-- | Used for marking occurrences of the parameter
newtype Par1 p
Par1 :: p -> Par1 p
[unPar1] :: Par1 p -> p

-- | Recursive calls of kind <tt>* -&gt; *</tt> (or kind <tt>k -&gt;
--   *</tt>, when <tt>PolyKinds</tt> is enabled)
newtype Rec1 (f :: k -> Type) (p :: k)
Rec1 :: f p -> Rec1 (f :: k -> Type) (p :: k)
[unRec1] :: Rec1 (f :: k -> Type) (p :: k) -> f p

-- | Constants, additional parameters and recursion of kind <tt>*</tt>
newtype K1 i c (p :: k)
K1 :: c -> K1 i c (p :: k)
[unK1] :: K1 i c (p :: k) -> c

-- | Meta-information (constructor names, etc.)
newtype M1 i (c :: Meta) (f :: k -> Type) (p :: k)
M1 :: f p -> M1 i (c :: Meta) (f :: k -> Type) (p :: k)
[unM1] :: M1 i (c :: Meta) (f :: k -> Type) (p :: k) -> f p

-- | Sums: encode choice between constructors
data ( (f :: k -> Type) :+: (g :: k -> Type) ) (p :: k)
L1 :: f p -> (:+:) (f :: k -> Type) (g :: k -> Type) (p :: k)
R1 :: g p -> (:+:) (f :: k -> Type) (g :: k -> Type) (p :: k)
infixr 5 :+:

-- | Products: encode multiple arguments to constructors
data ( (f :: k -> Type) :*: (g :: k -> Type) ) (p :: k)
(:*:) :: f p -> g p -> (:*:) (f :: k -> Type) (g :: k -> Type) (p :: k)
infixr 6 :*:
infixr 6 :*:

-- | Composition of functors
newtype ( (f :: k2 -> Type) :.: (g :: k1 -> k2) ) (p :: k1)
Comp1 :: f (g p) -> (:.:) (f :: k2 -> Type) (g :: k1 -> k2) (p :: k1)
[unComp1] :: (:.:) (f :: k2 -> Type) (g :: k1 -> k2) (p :: k1) -> f (g p)
infixr 7 :.:

-- | Tag for K1: recursion (of kind <tt>Type</tt>)
data R

-- | Tag for M1: datatype
data D

-- | Tag for M1: constructor
data C

-- | Tag for M1: record selector
data S

-- | Type synonym for encoding recursion (of kind <tt>Type</tt>)
type Rec0 = K1 R :: Type -> k -> Type

-- | Type synonym for encoding meta-information for datatypes
type D1 = M1 D :: Meta -> k -> Type -> k -> Type

-- | Type synonym for encoding meta-information for constructors
type C1 = M1 C :: Meta -> k -> Type -> k -> Type

-- | Type synonym for encoding meta-information for record selectors
type S1 = M1 S :: Meta -> k -> Type -> k -> Type

-- | Generic representation type
type family Rep a :: Type -> Type

-- | Generic representation type
type family Rep1 (f :: k -> Type) :: k -> Type

-- | Constants of unlifted kinds
data family URec a (p :: k)

-- | Type synonym for <tt><a>URec</a> <a>Addr#</a></tt>
type UAddr = URec Ptr () :: k -> Type

-- | Type synonym for <tt><a>URec</a> <a>Char#</a></tt>
type UChar = URec Char :: k -> Type

-- | Type synonym for <tt><a>URec</a> <a>Double#</a></tt>
type UDouble = URec Double :: k -> Type

-- | Type synonym for <tt><a>URec</a> <a>Float#</a></tt>
type UFloat = URec Float :: k -> Type

-- | Type synonym for <tt><a>URec</a> <a>Int#</a></tt>
type UInt = URec Int :: k -> Type

-- | Type synonym for <tt><a>URec</a> <a>Word#</a></tt>
type UWord = URec Word :: k -> Type

-- | Get the precedence of a fixity value.
prec :: Fixity -> Int

-- | Datatype to represent the fixity of a constructor. An infix |
--   declaration directly corresponds to an application of <a>Infix</a>.
data Fixity
Prefix :: Fixity
Infix :: Associativity -> Int -> Fixity

-- | This variant of <a>Fixity</a> appears at the type level.
data FixityI
PrefixI :: FixityI
InfixI :: Associativity -> Nat -> FixityI

-- | Datatype to represent the associativity of a constructor
data Associativity
LeftAssociative :: Associativity
RightAssociative :: Associativity
NotAssociative :: Associativity

-- | The unpackedness of a field as the user wrote it in the source code.
--   For example, in the following data type:
--   
--   <pre>
--   data E = ExampleConstructor     Int
--              {-# NOUNPACK #-} Int
--              {-#   UNPACK #-} Int
--   </pre>
--   
--   The fields of <tt>ExampleConstructor</tt> have
--   <a>NoSourceUnpackedness</a>, <a>SourceNoUnpack</a>, and
--   <a>SourceUnpack</a>, respectively.
data SourceUnpackedness
NoSourceUnpackedness :: SourceUnpackedness
SourceNoUnpack :: SourceUnpackedness
SourceUnpack :: SourceUnpackedness

-- | The strictness of a field as the user wrote it in the source code. For
--   example, in the following data type:
--   
--   <pre>
--   data E = ExampleConstructor Int ~Int !Int
--   </pre>
--   
--   The fields of <tt>ExampleConstructor</tt> have
--   <a>NoSourceStrictness</a>, <a>SourceLazy</a>, and <a>SourceStrict</a>,
--   respectively.
data SourceStrictness
NoSourceStrictness :: SourceStrictness
SourceLazy :: SourceStrictness
SourceStrict :: SourceStrictness

-- | The strictness that GHC infers for a field during compilation. Whereas
--   there are nine different combinations of <a>SourceUnpackedness</a> and
--   <a>SourceStrictness</a>, the strictness that GHC decides will
--   ultimately be one of lazy, strict, or unpacked. What GHC decides is
--   affected both by what the user writes in the source code and by GHC
--   flags. As an example, consider this data type:
--   
--   <pre>
--   data E = ExampleConstructor {-# UNPACK #-} !Int !Int Int
--   </pre>
--   
--   <ul>
--   <li>If compiled without optimization or other language extensions,
--   then the fields of <tt>ExampleConstructor</tt> will have
--   <a>DecidedStrict</a>, <a>DecidedStrict</a>, and <a>DecidedLazy</a>,
--   respectively.</li>
--   <li>If compiled with <tt>-XStrictData</tt> enabled, then the fields
--   will have <a>DecidedStrict</a>, <a>DecidedStrict</a>, and
--   <a>DecidedStrict</a>, respectively.</li>
--   <li>If compiled with <tt>-O2</tt> enabled, then the fields will have
--   <a>DecidedUnpack</a>, <a>DecidedStrict</a>, and <a>DecidedLazy</a>,
--   respectively.</li>
--   </ul>
data DecidedStrictness
DecidedLazy :: DecidedStrictness
DecidedStrict :: DecidedStrictness
DecidedUnpack :: DecidedStrictness

-- | Datatype to represent metadata associated with a datatype
--   (<tt>MetaData</tt>), constructor (<tt>MetaCons</tt>), or field
--   selector (<tt>MetaSel</tt>).
--   
--   <ul>
--   <li>In <tt>MetaData n m p nt</tt>, <tt>n</tt> is the datatype's name,
--   <tt>m</tt> is the module in which the datatype is defined, <tt>p</tt>
--   is the package in which the datatype is defined, and <tt>nt</tt> is
--   <tt>'True</tt> if the datatype is a <tt>newtype</tt>.</li>
--   <li>In <tt>MetaCons n f s</tt>, <tt>n</tt> is the constructor's name,
--   <tt>f</tt> is its fixity, and <tt>s</tt> is <tt>'True</tt> if the
--   constructor contains record selectors.</li>
--   <li>In <tt>MetaSel mn su ss ds</tt>, if the field uses record syntax,
--   then <tt>mn</tt> is <a>Just</a> the record name. Otherwise,
--   <tt>mn</tt> is <a>Nothing</a>. <tt>su</tt> and <tt>ss</tt> are the
--   field's unpackedness and strictness annotations, and <tt>ds</tt> is
--   the strictness that GHC infers for the field.</li>
--   </ul>
data Meta
MetaData :: Symbol -> Symbol -> Symbol -> Bool -> Meta
MetaCons :: Symbol -> FixityI -> Bool -> Meta
MetaSel :: Maybe Symbol -> SourceUnpackedness -> SourceStrictness -> DecidedStrictness -> Meta

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt><a>undefined</a> :: a</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data Proxy (t :: k)
Proxy :: Proxy (t :: k)
adtNamesMap :: (adtName1 -> adtName2) -> (consName1 -> consName2) -> ADT adtName1 consName1 ref -> ADT adtName2 consName2 ref
conTreeNameFold :: Monoid a => (name -> a) -> ConTree name t -> a
conTreeNameMap :: (name -> name2) -> ConTree name t -> ConTree name2 t
conTreeTypeFoldMap :: Monoid a => (Type t -> a) -> ConTree name t -> a
conTreeTypeList :: ConTree name t -> [Type t]
conTreeTypeMap :: (Type t -> Type ref) -> ConTree name t -> ConTree name ref
constructorInfo :: Eq consName => consName -> ConTree consName t -> Maybe ([Bool], [Type t])
constructors :: ConTree name ref -> [(name, Fields name ref)]
contree :: [(name, Fields name ref)] -> Maybe (ConTree name ref)
fieldsNames :: Either t [(a, t1)] -> [t1]
fieldsTypes :: Either [b] [(a, b)] -> [b]
getHRef :: TypeRef a -> Maybe a
nestedTypeNs :: TypeN t -> [TypeN t]
qualName :: QualName -> String
solve :: (Ord k, Show k) => k -> Map k a -> a
solveAll :: (Functor f, Show k, Ord k) => Map k b -> f k -> f b
typeA :: TypeN ref -> Type ref
typeADTs :: TypeModel adtName consName inRef k -> [ADT adtName consName inRef]
typeN :: Type r -> TypeN r
unVar :: TypeRef t -> t
data ADT name consName ref
ADT :: name -> Word8 -> Maybe (ConTree consName ref) -> ADT name consName ref
[declName] :: ADT name consName ref -> name
[declNumParameters] :: ADT name consName ref -> Word8
[declCons] :: ADT name consName ref -> Maybe (ConTree consName ref)
data ConTree name ref
Con :: name -> Fields name ref -> ConTree name ref
[constrName] :: ConTree name ref -> name
[constrFields] :: ConTree name ref -> Fields name ref
ConTree :: ConTree name ref -> ConTree name ref -> ConTree name ref
type Fields name ref = Either [Type ref] [(name, Type ref)]
type HADT = ADT String String HTypeRef
type HType = Type HTypeRef
type HTypeEnv = TypeEnv String String TypeRef QualName QualName
type HTypeModel = TypeModel String String TypeRef QualName QualName
type HTypeRef = TypeRef QualName
data QualName
QualName :: String -> String -> String -> QualName
[pkgName] :: QualName -> String
[mdlName] :: QualName -> String
[locName] :: QualName -> String
data Type ref
TypeCon :: ref -> Type ref
TypeApp :: Type ref -> Type ref -> Type ref
type TypeEnv adtName consName inRef exRef = Map exRef ADT adtName consName inRef
data TypeModel adtName consName inRef exRef
TypeModel :: Type exRef -> TypeEnv adtName consName inRef exRef -> TypeModel adtName consName inRef exRef
[typeName] :: TypeModel adtName consName inRef exRef -> Type exRef
[typeEnv] :: TypeModel adtName consName inRef exRef -> TypeEnv adtName consName inRef exRef
data TypeN r
TypeN :: r -> [TypeN r] -> TypeN r
data TypeRef name
TypVar :: Word8 -> TypeRef name
TypRef :: name -> TypeRef name

-- | An absolute type model, an absolute type and its associated
--   environment
type AbsTypeModel = TypeModel Identifier Identifier (ADTRef AbsRef) AbsRef

-- | An absolute type, a type identifier that depends only on the
--   definition of the type
type AbsType = Type AbsRef

-- | A reference to an absolute data type definition, in the form of a hash
--   of the data type definition itself data AbsRef = AbsRef (SHA3_256_6
--   AbsADT) deriving (Eq, Ord, Show, NFData, Generic, Flat)
newtype AbsRef
AbsRef :: SHAKE128_48 AbsADT -> AbsRef

-- | Return the absolute reference of the given value
absRef :: AbsADT -> AbsRef

-- | An absolute data type definition, a definition that refers only to
--   other absolute definitions
type AbsADT = ADT Identifier Identifier (ADTRef AbsRef)

-- | An environments of absolute types
type AbsEnv = TypeEnv Identifier Identifier (ADTRef AbsRef) AbsRef

-- | A reference inside an ADT to another ADT
data ADTRef r

-- | Variable, standing for a type
Var :: Word8 -> ADTRef r

-- | Recursive reference to the ADT itself
Rec :: ADTRef r

-- | Reference to another ADT
Ext :: r -> ADTRef r

-- | Return an external reference, if present
getADTRef :: ADTRef a -> Maybe a
toTypeRef :: name -> ADTRef name -> TypeRef name
substAbsADT :: (AbsRef -> b) -> AbsADT -> ADT Identifier Identifier (TypeRef b)

-- | Validate a string as an Identifier &gt;&gt;&gt; asIdentifier
--   <a>Id_1</a> Success (Name (UnicodeLetter <tt>I</tt>)
--   [UnicodeLetterOrNumberOrLine <tt>d</tt>,UnicodeLetterOrNumberOrLine
--   '_',UnicodeLetterOrNumberOrLine '1'])
--   
--   <pre>
--   &gt;&gt;&gt; asIdentifier "&lt;&gt;"
--   Success (Symbol (Cons (UnicodeSymbol '&lt;') (Elem (UnicodeSymbol '&gt;'))))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; asIdentifier ""
--   Failure ["identifier cannot be empty"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; asIdentifier "a*^"
--   Failure ["In a*^: '*' is not an Unicode Letter or Number or a _","In a*^: '^' is not an Unicode Letter or Number or a _"]
--   </pre>
asIdentifier :: String -> Validation Errors Identifier

-- | An Identifier, the name of an ADT
data Identifier
Name :: UnicodeLetter -> [UnicodeLetterOrNumberOrLine] -> Identifier
Symbol :: NonEmptyList UnicodeSymbol -> Identifier

-- | A character that is included in one of the following Unicode classes:
--   UppercaseLetter LowercaseLetter TitlecaseLetter ModifierLetter
--   OtherLetter
newtype UnicodeLetter
UnicodeLetter :: Char -> UnicodeLetter

-- | A character that is either a <a>UnicodeLetter</a>, a
--   <a>UnicodeNumber</a> or the special character '_'
newtype UnicodeLetterOrNumberOrLine
UnicodeLetterOrNumberOrLine :: Char -> UnicodeLetterOrNumberOrLine

-- | A character that is included in one of the following Unicode classes:
--   MathSymbol CurrencySymbol ModifierSymbol OtherSymbol
newtype UnicodeSymbol
UnicodeSymbol :: Char -> UnicodeSymbol

-- | A hash of a value, the first 6 bytes of the value's SHA3-256 hash
data SHA3_256_6 a
SHA3_256_6 :: Word8 -> Word8 -> Word8 -> Word8 -> Word8 -> Word8 -> SHA3_256_6 a

-- | A hash of a value, the first 48 bits (6 bytes) of the value's SHAKE128
--   hash
data SHAKE128_48 a
SHAKE128_48 :: Word8 -> Word8 -> Word8 -> Word8 -> Word8 -> Word8 -> SHAKE128_48 a

-- | Return the SHAKE128_48 reference of the given value
shake128_48 :: Flat a => a -> SHAKE128_48 a

-- | Return the SHAKE128_48 reference of the given ByteString
shake128_48_BS :: ByteString -> SHAKE128_48 a

-- | A list that contains at least one element
data NonEmptyList a
Elem :: a -> NonEmptyList a
Cons :: a -> NonEmptyList a -> NonEmptyList a

-- | Convert a list to a <a>NonEmptyList</a>, returns an error if the list
--   is empty
nonEmptyList :: [a] -> NonEmptyList a

-- | A 7 bits unsigned integer data Word7 = V0 .. V127
data Word7

-- | Flat encoding
data FlatEncoding
FlatEncoding :: FlatEncoding

-- | UTF-8 Encoding
data UTF8Encoding
UTF8Encoding :: UTF8Encoding

-- | UTF-16 Little Endian Encoding
data UTF16LEEncoding
UTF16LEEncoding :: UTF16LEEncoding

-- | Unspecified encoding
data NoEncoding
NoEncoding :: NoEncoding
type TypedDecoded a = Either TypedDecodeException a

-- | An exception thrown if the decoding of a type value fails
data TypedDecodeException
UnknownMetaModel :: AbsType -> TypedDecodeException
WrongType :: AbsType -> AbsType -> TypedDecodeException
[expectedType] :: TypedDecodeException -> AbsType
[actualType] :: TypedDecodeException -> AbsType
DecodeError :: DecodeException -> TypedDecodeException

-- | Violations of ZM model constrains
data ZMError t
UnknownType :: t -> ZMError t
WrongKind :: t -> Int -> ZMError t
[reference] :: ZMError t -> t
[expectedArity, actualArity] :: ZMError t -> Int
MutuallyRecursive :: [t] -> ZMError t

-- | A class of types that can be fully evaluated.
class NFData a
class Flat a

-- | ZigZag encoding, map signed integers to unsigned integers Positive
--   integers are mapped to even unsigned values, negative integers to odd
--   values: 0 -&gt; 0, -1 -&gt; 1, 1 -&gt; 2, -2 -&gt; 3, 2 -&gt; 4 ...
data ZigZag a
ZigZag :: a -> ZigZag a
data LeastSignificantFirst a
LeastSignificantFirst :: a -> LeastSignificantFirst a
data MostSignificantFirst a
MostSignificantFirst :: a -> MostSignificantFirst a
instance Flat.Class.Flat (ZM.Types.SHA3_256_6 a)
instance GHC.Generics.Generic (ZM.Types.SHA3_256_6 a)
instance Control.DeepSeq.NFData (ZM.Types.SHA3_256_6 a)
instance GHC.Show.Show (ZM.Types.SHA3_256_6 a)
instance GHC.Classes.Ord (ZM.Types.SHA3_256_6 a)
instance GHC.Classes.Eq (ZM.Types.SHA3_256_6 a)
instance Flat.Class.Flat (ZM.Types.SHAKE128_48 a)
instance GHC.Generics.Generic (ZM.Types.SHAKE128_48 a)
instance Control.DeepSeq.NFData (ZM.Types.SHAKE128_48 a)
instance GHC.Show.Show (ZM.Types.SHAKE128_48 a)
instance GHC.Classes.Ord (ZM.Types.SHAKE128_48 a)
instance GHC.Classes.Eq (ZM.Types.SHAKE128_48 a)
instance Flat.Class.Flat r => Flat.Class.Flat (ZM.Types.ADTRef r)
instance Data.Traversable.Traversable ZM.Types.ADTRef
instance Data.Foldable.Foldable ZM.Types.ADTRef
instance GHC.Base.Functor ZM.Types.ADTRef
instance GHC.Generics.Generic (ZM.Types.ADTRef r)
instance Control.DeepSeq.NFData r => Control.DeepSeq.NFData (ZM.Types.ADTRef r)
instance GHC.Show.Show r => GHC.Show.Show (ZM.Types.ADTRef r)
instance GHC.Classes.Ord r => GHC.Classes.Ord (ZM.Types.ADTRef r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (ZM.Types.ADTRef r)
instance Flat.Class.Flat ZM.Types.UnicodeLetterOrNumberOrLine
instance GHC.Generics.Generic ZM.Types.UnicodeLetterOrNumberOrLine
instance Control.DeepSeq.NFData ZM.Types.UnicodeLetterOrNumberOrLine
instance GHC.Show.Show ZM.Types.UnicodeLetterOrNumberOrLine
instance GHC.Classes.Ord ZM.Types.UnicodeLetterOrNumberOrLine
instance GHC.Classes.Eq ZM.Types.UnicodeLetterOrNumberOrLine
instance Flat.Class.Flat ZM.Types.UnicodeLetter
instance GHC.Generics.Generic ZM.Types.UnicodeLetter
instance Control.DeepSeq.NFData ZM.Types.UnicodeLetter
instance GHC.Show.Show ZM.Types.UnicodeLetter
instance GHC.Classes.Ord ZM.Types.UnicodeLetter
instance GHC.Classes.Eq ZM.Types.UnicodeLetter
instance Flat.Class.Flat ZM.Types.UnicodeNumber
instance GHC.Generics.Generic ZM.Types.UnicodeNumber
instance Control.DeepSeq.NFData ZM.Types.UnicodeNumber
instance GHC.Show.Show ZM.Types.UnicodeNumber
instance GHC.Classes.Ord ZM.Types.UnicodeNumber
instance GHC.Classes.Eq ZM.Types.UnicodeNumber
instance Flat.Class.Flat ZM.Types.UnicodeSymbol
instance GHC.Generics.Generic ZM.Types.UnicodeSymbol
instance Control.DeepSeq.NFData ZM.Types.UnicodeSymbol
instance GHC.Show.Show ZM.Types.UnicodeSymbol
instance GHC.Classes.Ord ZM.Types.UnicodeSymbol
instance GHC.Classes.Eq ZM.Types.UnicodeSymbol
instance Flat.Class.Flat ZM.Types.Identifier
instance GHC.Generics.Generic ZM.Types.Identifier
instance Control.DeepSeq.NFData ZM.Types.Identifier
instance GHC.Show.Show ZM.Types.Identifier
instance GHC.Classes.Ord ZM.Types.Identifier
instance GHC.Classes.Eq ZM.Types.Identifier
instance Flat.Class.Flat ZM.Types.AbsRef
instance GHC.Generics.Generic ZM.Types.AbsRef
instance Control.DeepSeq.NFData ZM.Types.AbsRef
instance GHC.Show.Show ZM.Types.AbsRef
instance GHC.Classes.Ord ZM.Types.AbsRef
instance GHC.Classes.Eq ZM.Types.AbsRef
instance Data.Foldable.Foldable ZM.Types.ZMError
instance GHC.Base.Functor ZM.Types.ZMError
instance GHC.Show.Show t => GHC.Show.Show (ZM.Types.ZMError t)
instance GHC.Classes.Ord ZM.Types.TypedDecodeException
instance GHC.Classes.Eq ZM.Types.TypedDecodeException
instance GHC.Show.Show ZM.Types.TypedDecodeException
instance GHC.Exception.Type.Exception ZM.Types.TypedDecodeException
instance Data.Model.Class.Model ZM.Types.AbsRef
instance Data.Convertible.Base.Convertible GHC.Base.String ZM.Types.Identifier
instance Data.Convertible.Base.Convertible ZM.Types.Identifier GHC.Base.String
instance Data.Model.Class.Model ZM.Types.Identifier
instance Data.Model.Class.Model ZM.Types.UnicodeSymbol
instance Data.Model.Class.Model ZM.Types.UnicodeLetter
instance Data.Model.Class.Model ZM.Types.UnicodeLetterOrNumberOrLine
instance Data.Model.Class.Model a => Data.Model.Class.Model (ZM.Types.ADTRef a)
instance Data.Model.Class.Model a => Data.Model.Class.Model (ZM.Types.SHAKE128_48 a)
instance Data.Model.Class.Model a => Data.Model.Class.Model (ZM.Types.SHA3_256_6 a)
instance (Flat.Class.Flat adtName, Flat.Class.Flat consName, Flat.Class.Flat inRef, Flat.Class.Flat exRef, GHC.Classes.Ord exRef) => Flat.Class.Flat (Data.Model.Types.TypeModel adtName consName inRef exRef)
instance (Flat.Class.Flat a, Flat.Class.Flat b, Flat.Class.Flat c) => Flat.Class.Flat (Data.Model.Types.ADT a b c)
instance (Flat.Class.Flat a, Flat.Class.Flat b) => Flat.Class.Flat (Data.Model.Types.ConTree a b)
instance Flat.Class.Flat a => Flat.Class.Flat (Data.Model.Types.Type a)
instance Flat.Class.Flat a => Flat.Class.Flat (Data.Model.Types.TypeRef a)
instance (Data.Model.Class.Model a, Data.Model.Class.Model b, Data.Model.Class.Model c) => Data.Model.Class.Model (Data.Model.Types.ADT a b c)
instance (Data.Model.Class.Model a, Data.Model.Class.Model b) => Data.Model.Class.Model (Data.Model.Types.ConTree a b)
instance Data.Model.Class.Model a => Data.Model.Class.Model (Data.Model.Types.Type a)
instance Data.Model.Class.Model a => Data.Model.Class.Model (Data.Model.Types.TypeRef a)
instance (Data.Model.Class.Model adtName, Data.Model.Class.Model consName, Data.Model.Class.Model inRef, Data.Model.Class.Model exRef) => Data.Model.Class.Model (Data.Model.Types.TypeModel adtName consName inRef exRef)
instance Data.Model.Class.Model a => Data.Model.Class.Model (Flat.Filler.PostAligned a)

module ZM.Type.Function
data Function f r
Call :: f -> Function f r
Reply :: SHAKE128_48 f -> r -> Function f r
instance (Flat.Class.Flat f, Flat.Class.Flat r) => Flat.Class.Flat (ZM.Type.Function.Function f r)
instance GHC.Generics.Generic (ZM.Type.Function.Function f r)
instance (GHC.Show.Show f, GHC.Show.Show r) => GHC.Show.Show (ZM.Type.Function.Function f r)
instance (GHC.Classes.Ord f, GHC.Classes.Ord r) => GHC.Classes.Ord (ZM.Type.Function.Function f r)
instance (GHC.Classes.Eq f, GHC.Classes.Eq r) => GHC.Classes.Eq (ZM.Type.Function.Function f r)
instance (Data.Model.Class.Model a, Data.Model.Class.Model b) => Data.Model.Class.Model (ZM.Type.Function.Function a b)

module ZM.Pretty.Base

-- | Display a list of Words in hexadecimal format
--   
--   <pre>
--   &gt;&gt;&gt; prettyWords [11,22,33::Word8]
--   0b1621
--   </pre>
prettyWords :: [Word8] -> Doc

-- | Display a Word in hexadecimal format
hex :: Word8 -> String
instance Text.PrettyPrint.HughesPJClass.Pretty t => Text.PrettyPrint.HughesPJClass.Pretty (ZM.Types.ZMError t)
instance Text.PrettyPrint.HughesPJClass.Pretty ZM.Types.AbsRef
instance Text.PrettyPrint.HughesPJClass.Pretty (ZM.Types.SHA3_256_6 a)
instance Text.PrettyPrint.HughesPJClass.Pretty (ZM.Types.SHAKE128_48 a)


-- | Pretty instances for some basic Haskell types and for data type models
module ZM.Pretty

-- | Display a Word in hexadecimal format
hex :: Word8 -> String

-- | Convert the textual representation of a hash code to its equivalent
--   value
--   
--   <pre>
--   &gt;&gt;&gt; unPrettyRef "Kb53bec846608"
--   SHAKE128_48 181 59 236 132 102 8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unPrettyRef "Kb53bec8466080000"
--   *** Exception: unPrettyRef: unknown code "b53bec8466080000"
--   ...
--   </pre>
unPrettyRef :: String -> SHAKE128_48 a

-- | Display a list of Docs, with spaced elements &gt;&gt;&gt; prettyList
--   (map pPrint [11,22,33::Word8]) [11, 22, 33]
prettyList :: [Doc] -> Doc

-- | Display a list of Docs, as a tuple with spaced elements
--   
--   <pre>
--   &gt;&gt;&gt; prettyTuple (map pPrint [11,22,33::Word8])
--   (11, 22, 33)
--   </pre>
prettyTuple :: [Doc] -> Doc
instance Text.PrettyPrint.HughesPJClass.Pretty ZM.Types.TypedDecodeException
instance Text.PrettyPrint.HughesPJClass.Pretty ZM.Types.AbsTypeModel
instance Text.PrettyPrint.HughesPJClass.Pretty ZM.Types.AbsEnv
instance Text.PrettyPrint.HughesPJClass.Pretty (ZM.Types.AbsEnv, ZM.Types.AbsType)
instance Text.PrettyPrint.HughesPJClass.Pretty (ZM.Types.AbsEnv, ZM.Types.AbsADT)
instance Text.PrettyPrint.HughesPJClass.Pretty ZM.Types.Identifier
instance Text.PrettyPrint.HughesPJClass.Pretty a => Text.PrettyPrint.HughesPJClass.Pretty (GHC.Base.String, ZM.Types.ADTRef a)
instance Text.PrettyPrint.HughesPJClass.Pretty a => Text.PrettyPrint.HughesPJClass.Pretty (ZM.Types.ADTRef a)
instance Text.PrettyPrint.HughesPJClass.Pretty a => Text.PrettyPrint.HughesPJClass.Pretty (Data.Sequence.Internal.Seq a)
instance Text.PrettyPrint.HughesPJClass.Pretty a => Text.PrettyPrint.HughesPJClass.Pretty (ZM.Type.NonEmptyList.NonEmptyList a)
instance Text.PrettyPrint.HughesPJClass.Pretty ZM.Type.BLOB.NoEncoding
instance Text.PrettyPrint.HughesPJClass.Pretty Data.Text.Internal.Text
instance Text.PrettyPrint.HughesPJClass.Pretty Flat.Instances.Text.UTF8Text
instance Text.PrettyPrint.HughesPJClass.Pretty Flat.Instances.Text.UTF16Text
instance Text.PrettyPrint.HughesPJClass.Pretty GHC.Types.Word
instance Text.PrettyPrint.HughesPJClass.Pretty GHC.Word.Word8
instance Text.PrettyPrint.HughesPJClass.Pretty GHC.Word.Word16
instance Text.PrettyPrint.HughesPJClass.Pretty GHC.Word.Word32
instance Text.PrettyPrint.HughesPJClass.Pretty GHC.Word.Word64
instance Text.PrettyPrint.HughesPJClass.Pretty GHC.Int.Int8
instance Text.PrettyPrint.HughesPJClass.Pretty GHC.Int.Int16
instance Text.PrettyPrint.HughesPJClass.Pretty GHC.Int.Int32
instance Text.PrettyPrint.HughesPJClass.Pretty GHC.Int.Int64
instance Text.PrettyPrint.HughesPJClass.Pretty Data.ByteString.Internal.ByteString
instance Text.PrettyPrint.HughesPJClass.Pretty Data.ByteString.Lazy.Internal.ByteString
instance Text.PrettyPrint.HughesPJClass.Pretty Data.ByteString.Short.Internal.ShortByteString
instance (Text.PrettyPrint.HughesPJClass.Pretty a, Text.PrettyPrint.HughesPJClass.Pretty b) => Text.PrettyPrint.HughesPJClass.Pretty (Data.Map.Internal.Map a b)
instance (Text.PrettyPrint.HughesPJClass.Pretty a, Text.PrettyPrint.HughesPJClass.Pretty b, Text.PrettyPrint.HughesPJClass.Pretty c, Text.PrettyPrint.HughesPJClass.Pretty d, Text.PrettyPrint.HughesPJClass.Pretty e, Text.PrettyPrint.HughesPJClass.Pretty f, Text.PrettyPrint.HughesPJClass.Pretty g, Text.PrettyPrint.HughesPJClass.Pretty h, Text.PrettyPrint.HughesPJClass.Pretty i) => Text.PrettyPrint.HughesPJClass.Pretty (a, b, c, d, e, f, g, h, i)


-- | Derive absolute/canonical data type models
module ZM.Abs
absEnv :: Model a => Proxy a -> AbsEnv

-- | Derive an absolute type for a type, or throw an error if derivation is
--   impossible
absType :: Model a => Proxy a -> AbsType

-- | Derive an absolute type model for a type, or throw an error if
--   derivation is impossible
absTypeModel :: Model a => Proxy a -> AbsTypeModel

-- | Derive an absolute type model for a type, composed of the type plus
--   its full type environment (all the types the type depends upon
--   directly or indirectly)
--   
--   <pre>
--   &gt;&gt;&gt; let Right t = absTypeModelMaybe (Proxy :: Proxy [Bool]) in error . prettyShow $ t
--   Type: List Bool (Kb8cd13187198 K306f1981b41c)
--   Environment:
--   Bool.K306f1981b41c ≡   False
--                        | True;
--   List.Kb8cd13187198 a ≡   Nil
--                          | Cons a (List.Kb8cd13187198 a);
--   </pre>
--   
--   Mutual dependencies are not supported:
--   
--   <pre>
--   &gt;&gt;&gt; data A = A B deriving (Model,Generic);data B = B A deriving (Model,Generic)
--   
--   &gt;&gt;&gt; error . prettyShow $ absTypeModelMaybe (Proxy :: Proxy A)
--   Left [Found mutually recursive types: [interactive.Ghci2.B,
--                                          interactive.Ghci2.A]]
--   </pre>
--   
--   Higher kind types are also not supported (this is detected at compile
--   time as it is not possible to derive a Model instance):
--   
--   <pre>
--   &gt;&gt;&gt; data Free f a = Impure (f (Free f a)) | Pure a deriving Model
--   Could not deduce (AsType (Ana a))
--     arising from the 'deriving' clause of a data type declaration
--   from the context: (Typeable f, Typeable a)
--     bound by the deriving clause for ‘Model (Free f a)’
--     at &lt;interactive&gt;:1:58-62
--   Possible fix:
--     use a standalone 'deriving instance' declaration,
--       so you can specify the instance context yourself
--   </pre>
absTypeModelMaybe :: Model a => Proxy a -> Either [ZMError QualName] AbsTypeModel

-- | Convert a set of relative ADTs to the equivalent ZM absolute ADTs
relToAbsEnv :: (IsKey r, IsId n) => RelTypeEnv n r -> Either [ZMError r] AbsEnv

-- | Convert a set of relative ADTs to the equivalent ZM absolute ADTs,
--   with a starting set of known absolute ADTs.
--   
--   Conversion will fail if the relative ADTs are mutually recursive or
--   refer to undefined ADTs.
relToAbsEnvWith :: (IsKey r, IsId n) => AbsEnv -> RelTypeEnv n r -> Either [ZMError r] AbsEnv

-- | Check that all internal references in the ADT definitions are to ADTs
--   defined in the environment This test is also performed as part of the
--   relative to absolute conversion (<a>relToAbsEnv</a>)
refErrors :: (Foldable t, Eq t1) => Map t1 (t (ADTRef t1)) -> [ZMError t1]
kindErrors :: Ord k => Map k (ADT name1 name2 (TypeRef2 a k)) -> [ZMError (Either a k)]

-- | Check that all type expressions have kind <a>*</a>, that's to say:
--   
--   <ul>
--   <li>Type constructors are fully applied</li>
--   <li>Type variables have * kind</li>
--   </ul>
data TypeRef2 v r
Var2 :: v -> TypeRef2 v r
Ext2 :: r -> TypeRef2 v r
class KeyOf k a
keyOf :: KeyOf k a => a -> k

-- | Return the transitive closure of an element in a graph of dependencies
--   specified as an adjacency list
--   
--   <pre>
--   &gt;&gt;&gt; transitiveClosure Just (M.fromList [("a",["b","c"]),("b",["b","d","d","c"]),("c",[]),("d",["a"])]) "b"
--   Right ["c","a","d","b"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; transitiveClosure Just (M.fromList [("a",["b","c"]),("b",["b","d","d","c"]),("c",[]),("d",["a"])]) "c"
--   Right ["c"]
--   </pre>
transitiveClosure :: (Foldable t, Ord r) => (a -> Maybe r) -> Map r (t a) -> r -> Either [ZMError r] [r]
instance GHC.Show.Show r => GHC.Show.Show (ZM.Abs.RecState r)
instance ZM.Abs.KeyOf Data.Model.Types.QualName (ZM.Types.AbsRef, ZM.Types.AbsADT)

module ZM.Util

-- | Return the proxy for the type of the given value
proxyOf :: a -> Proxy a

-- | Run a State monad with an empty map as environment
runEnv :: State (Map k a1) a -> (a, Map k a1)

-- | Exec a State monad with an empty map as environment
execEnv :: State (Map k a1) a -> Map k a1


-- | Utilities to operate on the absolute type model
module ZM.Transform

-- | A map of fully applied types to the corresponding saturated
--   constructor tree
type MapTypeTree = Map (Type AbsRef) (ConTree Identifier AbsRef)

-- | Return the map of types to saturated constructor trees corresponding
--   to the type model
typeTree :: AbsTypeModel -> MapTypeTree

-- | Convert a type to an equivalent concrete ADT whose variables have been
--   substituted by the type parameters (e.g. Maybe Bool -&gt; Maybe =
--   Nothing | Just Bool)
solvedADT :: (Ord ref, Show ref) => Map ref (ADT name consName (ADTRef ref)) -> Type ref -> ADT name consName ref

-- | Return all the ADTs referred, directly or indirectly, by the provided
--   type, and defined in the provided environment
typeDefinition :: AbsEnv -> AbsType -> Either [ZMError AbsRef] [AbsADT]

-- | Return all the ADTs referred, directly or indirectly, by the ADT
--   identified by the provided reference, and defined in the provided
--   environment
adtDefinition :: AbsEnv -> AbsRef -> Either [ZMError AbsRef] [AbsADT]

-- | Return the list of references found in the ADT definition
innerReferences :: AbsADT -> [AbsRef]

-- | Return the list of references found in the absolute type
references :: AbsType -> [AbsRef]

module ZM.BLOB

-- | A BLOB is binary value encoded according to a specified encoding (e.g.
--   UTF8)
data BLOB encoding
BLOB :: encoding -> ByteString -> BLOB encoding
[encoding] :: BLOB encoding -> encoding
[content] :: BLOB encoding -> ByteString

-- | Build a BLOB from an encoding and a ByteString-like value
blob :: AsByteString a => encoding -> a -> BLOB encoding

-- | Extract the binary content of a BLOB
unblob :: BLOB t -> ByteString

-- | A typed value, a Flat encoded value and its absolute type
data TypedBLOB
TypedBLOB :: AbsType -> BLOB FlatEncoding -> TypedBLOB

-- | Build a TypedBLOB out of a value
typedBLOB :: forall a. (Model a, Flat a) => a -> TypedBLOB

-- | Build a TypedBLOB out of a type and a value
typedBLOB_ :: Flat a => AbsType -> a -> TypedBLOB

-- | Type-checked extraction of a value of a known type from a decoded
--   TypedBLOB
untypedBLOB :: forall a. (Flat a, Model a) => Decoded TypedBLOB -> TypedDecoded a

-- | A typed value, a value and its absolute type
data TypedValue a
TypedValue :: AbsType -> a -> TypedValue a

-- | Build a TypedValue out of a value
typedValue :: forall a. Model a => a -> TypedValue a

-- | Type-checked extraction of a value of a known type from a decoded
--   TypedValue
untypedValue :: Model a => Decoded (TypedValue a) -> TypedDecoded a

-- | Return a WrongType error
typeErr :: AbsType -> AbsType -> TypedDecoded a
instance Flat.Class.Flat encoding => Flat.Class.Flat (ZM.BLOB.BLOB encoding)
instance GHC.Generics.Generic (ZM.BLOB.BLOB encoding)
instance Control.DeepSeq.NFData encoding => Control.DeepSeq.NFData (ZM.BLOB.BLOB encoding)
instance GHC.Classes.Ord encoding => GHC.Classes.Ord (ZM.BLOB.BLOB encoding)
instance GHC.Classes.Eq encoding => GHC.Classes.Eq (ZM.BLOB.BLOB encoding)
instance Data.Model.Class.Model ZM.BLOB.TypedBLOB
instance Flat.Class.Flat ZM.BLOB.TypedBLOB
instance GHC.Generics.Generic ZM.BLOB.TypedBLOB
instance Control.DeepSeq.NFData ZM.BLOB.TypedBLOB
instance GHC.Show.Show ZM.BLOB.TypedBLOB
instance GHC.Classes.Ord ZM.BLOB.TypedBLOB
instance GHC.Classes.Eq ZM.BLOB.TypedBLOB
instance Flat.Class.Flat a => Flat.Class.Flat (ZM.BLOB.TypedValue a)
instance GHC.Generics.Generic (ZM.BLOB.TypedValue a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (ZM.BLOB.TypedValue a)
instance GHC.Base.Functor ZM.BLOB.TypedValue
instance GHC.Show.Show a => GHC.Show.Show (ZM.BLOB.TypedValue a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (ZM.BLOB.TypedValue a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (ZM.BLOB.TypedValue a)
instance GHC.Show.Show a => Text.PrettyPrint.HughesPJClass.Pretty (ZM.BLOB.TypedValue a)
instance Data.Model.Class.Model encoding => Data.Model.Class.Model (ZM.BLOB.BLOB encoding)
instance GHC.Show.Show encoding => GHC.Show.Show (ZM.BLOB.BLOB encoding)
instance GHC.Read.Read encoding => GHC.Read.Read (ZM.BLOB.BLOB encoding)
instance Text.PrettyPrint.HughesPJClass.Pretty encoding => Text.PrettyPrint.HughesPJClass.Pretty (ZM.BLOB.BLOB encoding)
instance Text.PrettyPrint.HughesPJClass.Pretty (ZM.BLOB.BLOB ZM.Type.BLOB.UTF8Encoding)
instance Text.PrettyPrint.HughesPJClass.Pretty (ZM.BLOB.BLOB ZM.Type.BLOB.UTF16LEEncoding)

module ZM

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <a>id</a>
--   <a>to</a> . <a>from</a> ≡ <a>id</a>
--   </pre>
class Generic a where {
    
    -- | Generic representation type
    type family Rep a :: Type -> Type;
}

-- | Convert from the datatype to its representation
from :: Generic a => a -> Rep a x

-- | Convert from the representation to the datatype
to :: Generic a => Rep a x -> a

-- | Representable types of kind <tt>* -&gt; *</tt> (or kind <tt>k -&gt;
--   *</tt>, when <tt>PolyKinds</tt> is enabled). This class is derivable
--   in GHC with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic1</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from1</a> . <a>to1</a> ≡ <a>id</a>
--   <a>to1</a> . <a>from1</a> ≡ <a>id</a>
--   </pre>
class Generic1 (f :: k -> Type) where {
    
    -- | Generic representation type
    type family Rep1 (f :: k -> Type) :: k -> Type;
}

-- | Convert from the datatype to its representation
from1 :: forall (a :: k). Generic1 f => f a -> Rep1 f a

-- | Convert from the representation to the datatype
to1 :: forall (a :: k). Generic1 f => Rep1 f a -> f a

-- | Class for datatypes that represent datatypes
class Datatype (d :: k)

-- | The name of the datatype (unqualified)
datatypeName :: forall k1 t (f :: k1 -> Type) (a :: k1). Datatype d => t d f a -> [Char]

-- | The fully-qualified name of the module where the type is declared
moduleName :: forall k1 t (f :: k1 -> Type) (a :: k1). Datatype d => t d f a -> [Char]

-- | The package name of the module where the type is declared
packageName :: forall k1 t (f :: k1 -> Type) (a :: k1). Datatype d => t d f a -> [Char]

-- | Marks if the datatype is actually a newtype
isNewtype :: forall k1 t (f :: k1 -> Type) (a :: k1). Datatype d => t d f a -> Bool

-- | Class for datatypes that represent data constructors
class Constructor (c :: k)

-- | The name of the constructor
conName :: forall k1 t (f :: k1 -> Type) (a :: k1). Constructor c => t c f a -> [Char]

-- | The fixity of the constructor
conFixity :: forall k1 t (f :: k1 -> Type) (a :: k1). Constructor c => t c f a -> Fixity

-- | Marks if this constructor is a record
conIsRecord :: forall k1 t (f :: k1 -> Type) (a :: k1). Constructor c => t c f a -> Bool

-- | Class for datatypes that represent records
class Selector (s :: k)

-- | The name of the selector
selName :: forall k1 t (f :: k1 -> Type) (a :: k1). Selector s => t s f a -> [Char]

-- | The selector's unpackedness annotation (if any)
selSourceUnpackedness :: forall k1 t (f :: k1 -> Type) (a :: k1). Selector s => t s f a -> SourceUnpackedness

-- | The selector's strictness annotation (if any)
selSourceStrictness :: forall k1 t (f :: k1 -> Type) (a :: k1). Selector s => t s f a -> SourceStrictness

-- | The strictness that the compiler inferred for the selector
selDecidedStrictness :: forall k1 t (f :: k1 -> Type) (a :: k1). Selector s => t s f a -> DecidedStrictness

-- | Void: used for datatypes without constructors
data V1 (p :: k)

-- | Unit: used for constructors without arguments
data U1 (p :: k)
U1 :: U1 (p :: k)

-- | Used for marking occurrences of the parameter
newtype Par1 p
Par1 :: p -> Par1 p
[unPar1] :: Par1 p -> p

-- | Recursive calls of kind <tt>* -&gt; *</tt> (or kind <tt>k -&gt;
--   *</tt>, when <tt>PolyKinds</tt> is enabled)
newtype Rec1 (f :: k -> Type) (p :: k)
Rec1 :: f p -> Rec1 (f :: k -> Type) (p :: k)
[unRec1] :: Rec1 (f :: k -> Type) (p :: k) -> f p

-- | Constants, additional parameters and recursion of kind <tt>*</tt>
newtype K1 i c (p :: k)
K1 :: c -> K1 i c (p :: k)
[unK1] :: K1 i c (p :: k) -> c

-- | Meta-information (constructor names, etc.)
newtype M1 i (c :: Meta) (f :: k -> Type) (p :: k)
M1 :: f p -> M1 i (c :: Meta) (f :: k -> Type) (p :: k)
[unM1] :: M1 i (c :: Meta) (f :: k -> Type) (p :: k) -> f p

-- | Sums: encode choice between constructors
data ( (f :: k -> Type) :+: (g :: k -> Type) ) (p :: k)
L1 :: f p -> (:+:) (f :: k -> Type) (g :: k -> Type) (p :: k)
R1 :: g p -> (:+:) (f :: k -> Type) (g :: k -> Type) (p :: k)
infixr 5 :+:

-- | Products: encode multiple arguments to constructors
data ( (f :: k -> Type) :*: (g :: k -> Type) ) (p :: k)
(:*:) :: f p -> g p -> (:*:) (f :: k -> Type) (g :: k -> Type) (p :: k)
infixr 6 :*:
infixr 6 :*:

-- | Composition of functors
newtype ( (f :: k2 -> Type) :.: (g :: k1 -> k2) ) (p :: k1)
Comp1 :: f (g p) -> (:.:) (f :: k2 -> Type) (g :: k1 -> k2) (p :: k1)
[unComp1] :: (:.:) (f :: k2 -> Type) (g :: k1 -> k2) (p :: k1) -> f (g p)
infixr 7 :.:

-- | Tag for K1: recursion (of kind <tt>Type</tt>)
data R

-- | Tag for M1: datatype
data D

-- | Tag for M1: constructor
data C

-- | Tag for M1: record selector
data S

-- | Type synonym for encoding recursion (of kind <tt>Type</tt>)
type Rec0 = K1 R :: Type -> k -> Type

-- | Type synonym for encoding meta-information for datatypes
type D1 = M1 D :: Meta -> k -> Type -> k -> Type

-- | Type synonym for encoding meta-information for constructors
type C1 = M1 C :: Meta -> k -> Type -> k -> Type

-- | Type synonym for encoding meta-information for record selectors
type S1 = M1 S :: Meta -> k -> Type -> k -> Type

-- | Generic representation type
type family Rep a :: Type -> Type

-- | Generic representation type
type family Rep1 (f :: k -> Type) :: k -> Type

-- | Constants of unlifted kinds
data family URec a (p :: k)

-- | Type synonym for <tt><a>URec</a> <a>Addr#</a></tt>
type UAddr = URec Ptr () :: k -> Type

-- | Type synonym for <tt><a>URec</a> <a>Char#</a></tt>
type UChar = URec Char :: k -> Type

-- | Type synonym for <tt><a>URec</a> <a>Double#</a></tt>
type UDouble = URec Double :: k -> Type

-- | Type synonym for <tt><a>URec</a> <a>Float#</a></tt>
type UFloat = URec Float :: k -> Type

-- | Type synonym for <tt><a>URec</a> <a>Int#</a></tt>
type UInt = URec Int :: k -> Type

-- | Type synonym for <tt><a>URec</a> <a>Word#</a></tt>
type UWord = URec Word :: k -> Type

-- | Get the precedence of a fixity value.
prec :: Fixity -> Int

-- | Datatype to represent the fixity of a constructor. An infix |
--   declaration directly corresponds to an application of <a>Infix</a>.
data Fixity
Prefix :: Fixity
Infix :: Associativity -> Int -> Fixity

-- | This variant of <a>Fixity</a> appears at the type level.
data FixityI
PrefixI :: FixityI
InfixI :: Associativity -> Nat -> FixityI

-- | Datatype to represent the associativity of a constructor
data Associativity
LeftAssociative :: Associativity
RightAssociative :: Associativity
NotAssociative :: Associativity

-- | The unpackedness of a field as the user wrote it in the source code.
--   For example, in the following data type:
--   
--   <pre>
--   data E = ExampleConstructor     Int
--              {-# NOUNPACK #-} Int
--              {-#   UNPACK #-} Int
--   </pre>
--   
--   The fields of <tt>ExampleConstructor</tt> have
--   <a>NoSourceUnpackedness</a>, <a>SourceNoUnpack</a>, and
--   <a>SourceUnpack</a>, respectively.
data SourceUnpackedness
NoSourceUnpackedness :: SourceUnpackedness
SourceNoUnpack :: SourceUnpackedness
SourceUnpack :: SourceUnpackedness

-- | The strictness of a field as the user wrote it in the source code. For
--   example, in the following data type:
--   
--   <pre>
--   data E = ExampleConstructor Int ~Int !Int
--   </pre>
--   
--   The fields of <tt>ExampleConstructor</tt> have
--   <a>NoSourceStrictness</a>, <a>SourceLazy</a>, and <a>SourceStrict</a>,
--   respectively.
data SourceStrictness
NoSourceStrictness :: SourceStrictness
SourceLazy :: SourceStrictness
SourceStrict :: SourceStrictness

-- | The strictness that GHC infers for a field during compilation. Whereas
--   there are nine different combinations of <a>SourceUnpackedness</a> and
--   <a>SourceStrictness</a>, the strictness that GHC decides will
--   ultimately be one of lazy, strict, or unpacked. What GHC decides is
--   affected both by what the user writes in the source code and by GHC
--   flags. As an example, consider this data type:
--   
--   <pre>
--   data E = ExampleConstructor {-# UNPACK #-} !Int !Int Int
--   </pre>
--   
--   <ul>
--   <li>If compiled without optimization or other language extensions,
--   then the fields of <tt>ExampleConstructor</tt> will have
--   <a>DecidedStrict</a>, <a>DecidedStrict</a>, and <a>DecidedLazy</a>,
--   respectively.</li>
--   <li>If compiled with <tt>-XStrictData</tt> enabled, then the fields
--   will have <a>DecidedStrict</a>, <a>DecidedStrict</a>, and
--   <a>DecidedStrict</a>, respectively.</li>
--   <li>If compiled with <tt>-O2</tt> enabled, then the fields will have
--   <a>DecidedUnpack</a>, <a>DecidedStrict</a>, and <a>DecidedLazy</a>,
--   respectively.</li>
--   </ul>
data DecidedStrictness
DecidedLazy :: DecidedStrictness
DecidedStrict :: DecidedStrictness
DecidedUnpack :: DecidedStrictness

-- | Datatype to represent metadata associated with a datatype
--   (<tt>MetaData</tt>), constructor (<tt>MetaCons</tt>), or field
--   selector (<tt>MetaSel</tt>).
--   
--   <ul>
--   <li>In <tt>MetaData n m p nt</tt>, <tt>n</tt> is the datatype's name,
--   <tt>m</tt> is the module in which the datatype is defined, <tt>p</tt>
--   is the package in which the datatype is defined, and <tt>nt</tt> is
--   <tt>'True</tt> if the datatype is a <tt>newtype</tt>.</li>
--   <li>In <tt>MetaCons n f s</tt>, <tt>n</tt> is the constructor's name,
--   <tt>f</tt> is its fixity, and <tt>s</tt> is <tt>'True</tt> if the
--   constructor contains record selectors.</li>
--   <li>In <tt>MetaSel mn su ss ds</tt>, if the field uses record syntax,
--   then <tt>mn</tt> is <a>Just</a> the record name. Otherwise,
--   <tt>mn</tt> is <a>Nothing</a>. <tt>su</tt> and <tt>ss</tt> are the
--   field's unpackedness and strictness annotations, and <tt>ds</tt> is
--   the strictness that GHC infers for the field.</li>
--   </ul>
data Meta
MetaData :: Symbol -> Symbol -> Symbol -> Bool -> Meta
MetaCons :: Symbol -> FixityI -> Bool -> Meta
MetaSel :: Maybe Symbol -> SourceUnpackedness -> SourceStrictness -> DecidedStrictness -> Meta

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt><a>undefined</a> :: a</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data Proxy (t :: k)
Proxy :: Proxy (t :: k)

-- | Pretty print a value with the <a>prettyNormal</a> level.
prettyShow :: Pretty a => a -> String

-- | Pretty printing class. The precedence level is used in a similar way
--   as in the <a>Show</a> class. Minimal complete definition is either
--   <a>pPrintPrec</a> or <a>pPrint</a>.
class Pretty a
pPrintPrec :: Pretty a => PrettyLevel -> Rational -> a -> Doc
pPrint :: Pretty a => a -> Doc
pPrintList :: Pretty a => PrettyLevel -> [a] -> Doc
convert :: Convertible a b => a -> b
typeModel :: AsType (Ana a) => Proxy a -> HTypeModel
useCT :: Typeable a => Maybe (ConTree String HTypeRef) -> proxy a -> State Env (Type (TypeRef QualName))
dottedP :: [String] -> Doc
prettyADT :: (Pretty name, Pretty consName, Pretty ref) => String -> Char -> ADT name consName ref -> Doc
spacedP :: Pretty a => [a] -> Doc
varC :: Integral a => a -> Char
varP :: Integral n => n -> Doc
vspacedP :: Pretty a => [a] -> Doc
adtNamesMap :: (adtName1 -> adtName2) -> (consName1 -> consName2) -> ADT adtName1 consName1 ref -> ADT adtName2 consName2 ref
conTreeNameFold :: Monoid a => (name -> a) -> ConTree name t -> a
conTreeNameMap :: (name -> name2) -> ConTree name t -> ConTree name2 t
conTreeTypeFoldMap :: Monoid a => (Type t -> a) -> ConTree name t -> a
conTreeTypeList :: ConTree name t -> [Type t]
conTreeTypeMap :: (Type t -> Type ref) -> ConTree name t -> ConTree name ref
constructorInfo :: Eq consName => consName -> ConTree consName t -> Maybe ([Bool], [Type t])
constructors :: ConTree name ref -> [(name, Fields name ref)]
contree :: [(name, Fields name ref)] -> Maybe (ConTree name ref)
fieldsNames :: Either t [(a, t1)] -> [t1]
fieldsTypes :: Either [b] [(a, b)] -> [b]
getHRef :: TypeRef a -> Maybe a
nestedTypeNs :: TypeN t -> [TypeN t]
qualName :: QualName -> String
solve :: (Ord k, Show k) => k -> Map k a -> a
solveAll :: (Functor f, Show k, Ord k) => Map k b -> f k -> f b
typeA :: TypeN ref -> Type ref
typeADTs :: TypeModel adtName consName inRef k -> [ADT adtName consName inRef]
typeN :: Type r -> TypeN r
unVar :: TypeRef t -> t
convertOrError :: Convertible a c => a -> Either String c
convertResultToError :: Bifunctor p => p ConvertError c -> p String c
convertResultToErrors :: Bifunctor p => p ConvertError c -> p [String] c
dotted :: [String] -> String
errorToConvertResult :: (Typeable b, Typeable a, Show a) => (a -> Either Error b) -> a -> ConvertResult b
errorsToConvertResult :: (Typeable b, Typeable t, Show t) => (t -> Either Errors b) -> t -> ConvertResult b
errsInContext :: (Convertible ctx String, Bifunctor p) => ctx -> p [String] c -> p [String] c
inContext :: Convertible ctx String => ctx -> [String] -> [String]
noErrors :: Errors -> Bool
toErrors :: Bifunctor p => p a c -> p [a] c
data ConvertError
ConvertError :: String -> String -> String -> String -> ConvertError
[convSourceValue] :: ConvertError -> String
[convSourceType] :: ConvertError -> String
[convDestType] :: ConvertError -> String
[convErrorMessage] :: ConvertError -> String
type ConvertResult a = Either ConvertError a
class Convertible a b
safeConvert :: Convertible a b => a -> ConvertResult b
class AsType a
asType :: AsType a => a -> State Env HType
class (Typeable a, AsType Ana a) => Model a
envType :: Model a => Proxy a -> State Env HType
newtype CompactPretty a
CompactPretty :: a -> CompactPretty a
data ADT name consName ref
ADT :: name -> Word8 -> Maybe (ConTree consName ref) -> ADT name consName ref
[declName] :: ADT name consName ref -> name
[declNumParameters] :: ADT name consName ref -> Word8
[declCons] :: ADT name consName ref -> Maybe (ConTree consName ref)
data ConTree name ref
Con :: name -> Fields name ref -> ConTree name ref
[constrName] :: ConTree name ref -> name
[constrFields] :: ConTree name ref -> Fields name ref
ConTree :: ConTree name ref -> ConTree name ref -> ConTree name ref
type Fields name ref = Either [Type ref] [(name, Type ref)]
type HADT = ADT String String HTypeRef
type HType = Type HTypeRef
type HTypeEnv = TypeEnv String String TypeRef QualName QualName
type HTypeModel = TypeModel String String TypeRef QualName QualName
type HTypeRef = TypeRef QualName
data QualName
QualName :: String -> String -> String -> QualName
[pkgName] :: QualName -> String
[mdlName] :: QualName -> String
[locName] :: QualName -> String
data Type ref
TypeCon :: ref -> Type ref
TypeApp :: Type ref -> Type ref -> Type ref
type TypeEnv adtName consName inRef exRef = Map exRef ADT adtName consName inRef
data TypeModel adtName consName inRef exRef
TypeModel :: Type exRef -> TypeEnv adtName consName inRef exRef -> TypeModel adtName consName inRef exRef
[typeName] :: TypeModel adtName consName inRef exRef -> Type exRef
[typeEnv] :: TypeModel adtName consName inRef exRef -> TypeEnv adtName consName inRef exRef
data TypeN r
TypeN :: r -> [TypeN r] -> TypeN r
data TypeRef name
TypVar :: Word8 -> TypeRef name
TypRef :: name -> TypeRef name
type Errors = [Error]
type family Ana t

-- | A typed value, a value and its absolute type
data TypedValue a
TypedValue :: AbsType -> a -> TypedValue a

-- | A typed value, a Flat encoded value and its absolute type
data TypedBLOB
TypedBLOB :: AbsType -> BLOB FlatEncoding -> TypedBLOB

-- | A BLOB is binary value encoded according to a specified encoding (e.g.
--   UTF8)
data BLOB encoding
BLOB :: encoding -> ByteString -> BLOB encoding

-- | Extract the binary content of a BLOB
unblob :: BLOB t -> ByteString

-- | Build a BLOB from an encoding and a ByteString-like value
blob :: AsByteString a => encoding -> a -> BLOB encoding

-- | Build a TypedBLOB out of a value
typedBLOB :: forall a. (Model a, Flat a) => a -> TypedBLOB

-- | Build a TypedBLOB out of a type and a value
typedBLOB_ :: Flat a => AbsType -> a -> TypedBLOB

-- | Build a TypedValue out of a value
typedValue :: forall a. Model a => a -> TypedValue a

-- | Type-checked extraction of a value of a known type from a decoded
--   TypedBLOB
untypedBLOB :: forall a. (Flat a, Model a) => Decoded TypedBLOB -> TypedDecoded a

-- | Type-checked extraction of a value of a known type from a decoded
--   TypedValue
untypedValue :: Model a => Decoded (TypedValue a) -> TypedDecoded a

-- | Return a WrongType error
typeErr :: AbsType -> AbsType -> TypedDecoded a

module ZM.Type.Repo0

-- | A (simplistic) protocol to permanently store and retrieve ADT
--   definitions.
data RepoProtocol

-- | Permanently record an absolute type
Record :: AbsADT -> RepoProtocol

-- | Retrieve the absolute type
Solve :: AbsRef -> RepoProtocol

-- | Return the absolute type identified by an absolute reference
Solved :: AbsRef -> AbsADT -> RepoProtocol

-- | Request the list of all known data types
AskDataTypes :: RepoProtocol

-- | Return the list of all known data types
KnownDataTypes :: [(AbsRef, AbsADT)] -> RepoProtocol
instance Data.Model.Class.Model ZM.Type.Repo0.RepoProtocol
instance Flat.Class.Flat ZM.Type.Repo0.RepoProtocol
instance GHC.Generics.Generic ZM.Type.Repo0.RepoProtocol
instance GHC.Show.Show ZM.Type.Repo0.RepoProtocol
instance GHC.Classes.Ord ZM.Type.Repo0.RepoProtocol
instance GHC.Classes.Eq ZM.Type.Repo0.RepoProtocol

module ZM.Parser.Types
type Parser = Parsec Void String

-- | A parsed ADT
data ADTParts
ADTParts :: AtAbsName -> [AtId] -> [(AtId, Fields AtId AtAbsName)] -> ADTParts
[name] :: ADTParts -> AtAbsName
[vars] :: ADTParts -> [AtId]
[constrs] :: ADTParts -> [(AtId, Fields AtId AtAbsName)]
asTypeName :: Maybe a -> Maybe b -> These a b
hasName :: These a b -> Bool
hasRef :: These a1 a -> Bool

-- | A data type name can be either local, or absolute, or both:
--   <a>Bool</a> | ".K306f1981b41c" | <a>Bool.K306f1981b41c</a>
type TypeName l = These l AbsRef
localTypeName :: These a b -> a
absTypeName :: These a b -> b
data Label l a
Label :: l -> a -> Label l a
[label] :: Label l a -> l
[object] :: Label l a -> a
type At v = Label Range v
type AtId = At Identifier
type AtAbsName = At (TypeName Identifier)
type AtError = At String
data Range
Range :: Word32 -> Range
[line, start, end] :: Range -> Word32
type Val lit binder = Fix (ValF lit binder)
data ValF lit binder r
ConstrF :: String -> Either [r] [(String, r)] -> ValF lit binder r

-- | A variable or a lit pattern (e.g. a string or a number)
LitF :: lit r -> ValF lit binder r

-- | A pattern that might bind a matched value to a name
BinderF :: binder -> ValF lit binder r
pattern Constr :: String -> Either [Val lit binder] [(String, Val lit binder)] -> Val lit binder
pattern VInteger :: Integer -> Val Literal binder
pattern VChar :: Char -> Val Literal binder
pattern VString :: String -> Val Literal binder
pattern VFloat :: Double -> Val Literal binder
pattern VArray :: [Val Literal binder] -> Val Literal binder
pattern PBind :: String -> Val lit Binder
pattern PWild :: Val lit Binder
newtype Fix (f :: Type -> Type)
Fix :: f (Fix f) -> Fix (f :: Type -> Type)
[unFix] :: Fix (f :: Type -> Type) -> f (Fix f)
data Annotate label f
Annotate :: label -> f (Annotate label f) -> Annotate label f
data Literal e
LInteger :: Integer -> Literal e
LFloat :: Double -> Literal e
LChar :: Char -> Literal e
LString :: String -> Literal e
LArray :: [e] -> Literal e
data Binder
Wild :: Binder
Bind :: String -> Binder
type Value = Annotate (AbsType, [Bool]) (ValF Literal Void)
pattern Value :: forall a b lit binder. a -> String -> b -> [Annotate (a, b) (ValF lit binder)] -> Annotate (a, b) (ValF lit binder)
valType :: forall a b (lit :: Type -> Type) binder. Annotate (a, b) (ValF lit binder) -> a
valName :: forall a b (lit :: Type -> Type) binder. Annotate (a, b) (ValF lit binder) -> String
valBits :: forall a b (lit :: Type -> Type) binder. Annotate (a, b) (ValF lit binder) -> b
valFields :: forall a b (lit :: Type -> Type) binder. Annotate (a, b) (ValF lit binder) -> [Annotate (a, b) (ValF lit binder)]

-- | Uninhabited data type
data Void

-- | A generic value (used for dynamic decoding) data Value = Value {
--   valType :: AbsType -- ^Type , valName :: String -- ^Constructor name
--   (duplicate info if we have abstype) , valBits :: [Bool] -- ^Bit
--   encoding/constructor id -- TODO: add field names (same info present in
--   abstype) , valFields :: [Value] -- ^Values to which the constructor is
--   applied, if any } deriving (Eq, Ord, Show, NFData, Generic, Flat) data
--   Void Value could also be expressed as type Value = Val (AbsType,
--   [Bool]) Literal Void v0 :: [Value0] v0 = [lit (.., [False,True]) (PInt
--   3) |A Pattern matches a subset of values of a ZM Type p1 :: [Pattern]
--   p1 = [lit "1:1" (PInt 3), Binder "1:2" PWild] type Pattern = Val ()
--   Literal Binder type Value = Val () Literal () data Val annotation lit
--   binder = Constr annotation String -- ^Name of the constructor (e.g.
--   <a>True</a>) (Either [Val annotation lit binder] [(String, Val
--   annotation lit binder)]) -- ^Constructor parameters, possibly named --
--   } -- ^A standard constructor, e.g. PCon <a>True</a> []
data Void1 a
instance Data.Model.Class.Model ZM.Parser.Types.Range
instance Flat.Class.Flat ZM.Parser.Types.Range
instance GHC.Generics.Generic ZM.Parser.Types.Range
instance GHC.Classes.Ord ZM.Parser.Types.Range
instance GHC.Classes.Eq ZM.Parser.Types.Range
instance GHC.Show.Show ZM.Parser.Types.Range
instance GHC.Base.Functor (ZM.Parser.Types.Label l)
instance (GHC.Show.Show l, GHC.Show.Show a) => GHC.Show.Show (ZM.Parser.Types.Label l a)
instance GHC.Show.Show ZM.Parser.Types.ADTParts
instance GHC.Show.Show e => GHC.Show.Show (ZM.Parser.Types.Literal e)
instance GHC.Classes.Ord e => GHC.Classes.Ord (ZM.Parser.Types.Literal e)
instance GHC.Classes.Eq e => GHC.Classes.Eq (ZM.Parser.Types.Literal e)
instance GHC.Show.Show ZM.Parser.Types.Binder
instance GHC.Classes.Ord ZM.Parser.Types.Binder
instance GHC.Classes.Eq ZM.Parser.Types.Binder
instance (GHC.Classes.Eq label, GHC.Classes.Eq (f (ZM.Parser.Types.Annotate label f))) => GHC.Classes.Eq (ZM.Parser.Types.Annotate label f)
instance (GHC.Classes.Ord label, GHC.Classes.Ord (f (ZM.Parser.Types.Annotate label f))) => GHC.Classes.Ord (ZM.Parser.Types.Annotate label f)
instance (GHC.Show.Show label, GHC.Show.Show (f (ZM.Parser.Types.Annotate label f))) => GHC.Show.Show (ZM.Parser.Types.Annotate label f)
instance (GHC.Classes.Eq r, GHC.Classes.Eq binder, GHC.Classes.Eq (lit r)) => GHC.Classes.Eq (ZM.Parser.Types.ValF lit binder r)
instance (GHC.Classes.Ord r, GHC.Classes.Ord binder, GHC.Classes.Ord (lit r)) => GHC.Classes.Ord (ZM.Parser.Types.ValF lit binder r)
instance (GHC.Show.Show r, GHC.Show.Show binder, GHC.Show.Show (lit r)) => GHC.Show.Show (ZM.Parser.Types.ValF lit binder r)
instance Text.PrettyPrint.HughesPJClass.Pretty ZM.Parser.Types.Value
instance Text.PrettyPrint.HughesPJClass.Pretty ZM.Parser.Types.ADTParts
instance (Text.PrettyPrint.HughesPJClass.Pretty l, Text.PrettyPrint.HughesPJClass.Pretty a) => Text.PrettyPrint.HughesPJClass.Pretty (ZM.Parser.Types.Label l a)
instance GHC.Classes.Eq p => GHC.Classes.Eq (ZM.Parser.Types.Label l p)
instance GHC.Classes.Ord a => GHC.Classes.Ord (ZM.Parser.Types.Label l a)
instance Data.Convertible.Base.Convertible a b => Data.Convertible.Base.Convertible (ZM.Parser.Types.Label l a) (ZM.Parser.Types.Label l b)
instance Data.Convertible.Base.Convertible a b => Data.Convertible.Base.Convertible (ZM.Parser.Types.Label l a) b
instance Text.PrettyPrint.HughesPJClass.Pretty ZM.Parser.Types.Range
instance Text.PrettyPrint.HughesPJClass.Pretty n => Text.PrettyPrint.HughesPJClass.Pretty (ZM.Parser.Types.TypeName n)


-- | Dynamical decoding of serialised typed values
module ZM.To.Decoder

-- | Decode a Flat encoded value with a known type model to the
--   corresponding Value.
--   
--   <pre>
--   &gt;&gt;&gt; decodeAbsTypeModel (absTypeModel (Proxy::Proxy Bool)) (flat True)
--   Right (Value {valType = TypeCon (AbsRef (SHAKE128_48 48 111 25 129 180 28)), valName = "True", valBits = [True], valFields = []})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeAbsTypeModel (absTypeModel (Proxy::Proxy (Maybe Bool))) (flat $ Just True) == Right (Value {valType = TypeApp (TypeCon (AbsRef (SHAKE128_48 218 104 54 119 143 212))) (TypeCon (AbsRef (SHAKE128_48 48 111 25 129 180 28))), valName = "Just", valBits = [True], valFields = [Value {valType = TypeCon (AbsRef (SHAKE128_48 48 111 25 129 180 28)), valName = "True", valBits = [True], valFields = []}]})
--   True
--   </pre>
--   
--   If we use the wrong type we get an error:
--   
--   <pre>
--   &gt;&gt;&gt; decodeAbsTypeModel (absTypeModel (Proxy::Proxy Word8)) (flat 1.1)
--   Left (TooMuchSpace ...
--   </pre>
--   
--   Or not, if the binary sequence happens to have the same length of a
--   value of the wrong type:
--   
--   <pre>
--   &gt;&gt;&gt; decodeAbsTypeModel (absTypeModel (Proxy::Proxy Word8)) (flat (11::Int)) == Right (Value {valType = TypeCon (AbsRef (SHAKE128_48 177 244 106 73 200 248)), valName = "V22", valBits = [False,False,False,True,False,True,True,False], valFields = []})
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeAbsTypeModel (absTypeModel (Proxy::Proxy Word8)) (flat (11::Word8)) == Right (Value {valType = TypeCon (AbsRef (SHAKE128_48 177 244 106 73 200 248)), valName = "V11", valBits = [False,False,False,False,True,False,True,True], valFields = []})
--   True
--   </pre>
--   
--   The valBits refer only to the bottom level:
--   
--   <pre>
--   &gt;&gt;&gt; decodeAbsTypeModel (absTypeModel (Proxy::Proxy (Maybe Bool))) (flat $ Just False)
--   Right (Annotate (TypeApp (TypeCon (AbsRef (SHAKE128_48 218 104 54 119 143 212))) (TypeCon (AbsRef (SHAKE128_48 48 111 25 129 180 28))),[True]) (ConstrF "Just" (Left [Annotate (TypeCon (AbsRef (SHAKE128_48 48 111 25 129 180 28)),[False]) (ConstrF "False" (Left []))])))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeAbsTypeModel (absTypeModel (Proxy::Proxy Char)) (flat 'a')
--   Right (Annotate (TypeCon (AbsRef (SHAKE128_48 6 109 181 42 241 69)),[]) (ConstrF "Char" (Left [Annotate (TypeCon (AbsRef (SHAKE128_48 36 18 121 156 153 241)),[]) (ConstrF "Word32" (Left [Annotate (TypeCon (AbsRef (SHAKE128_48 249 46 131 57 144 138)),[]) (ConstrF "Word" (Left [Annotate (TypeApp (TypeCon (AbsRef (SHAKE128_48 32 255 172 200 248 201))) (TypeApp (TypeCon (AbsRef (SHAKE128_48 191 45 28 134 235 32))) (TypeApp (TypeCon (AbsRef (SHAKE128_48 116 226 179 184 153 65))) (TypeCon (AbsRef (SHAKE128_48 244 201 70 51 74 126))))),[]) (ConstrF "LeastSignificantFirst" (Left [Annotate (TypeApp (TypeCon (AbsRef (SHAKE128_48 191 45 28 134 235 32))) (TypeApp (TypeCon (AbsRef (SHAKE128_48 116 226 179 184 153 65))) (TypeCon (AbsRef (SHAKE128_48 244 201 70 51 74 126)))),[False]) (ConstrF "Elem" (Left [Annotate (TypeApp (TypeCon (AbsRef (SHAKE128_48 116 226 179 184 153 65))) (TypeCon (AbsRef (SHAKE128_48 244 201 70 51 74 126))),[]) (ConstrF "MostSignificantFirst" (Left [Annotate (TypeCon (AbsRef (SHAKE128_48 244 201 70 51 74 126)),[True,True,False,False,False,False,True]) (ConstrF "V97" (Left []))]))]))]))]))]))])))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let Right (Value {valType = TypeApp (TypeCon (AbsRef (SHAKE128_48 184 205 19 24 113 152))) (TypeCon (AbsRef (SHAKE128_48 6 109 181 42 241 69))), valName = "Cons", valBits = [True] , valFields=_}) = decodeAbsTypeModel (absTypeModel (Proxy::Proxy String)) (flat "abc") in True
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; not True
--   </pre>
--   
--   TODO: implement pretty prettyShow <a>$</a> decodeAbsTypeModel
--   (absTypeModel (Proxy::Proxy Bool)) (flat True) Right <a>True</a>
--   
--   prettyShow <a>$</a> decodeAbsTypeModel (absTypeModel (Proxy::Proxy
--   Word8)) (flat (11 :: Word8)) Right "11"
decodeAbsTypeModel :: AbsTypeModel -> ByteString -> Decoded Value

-- | Returns a decoder for the type defined by the given model
typeDecoder :: AbsTypeModel -> Get Value

-- | Returns decoders for all types in the given model
typeDecoderMap :: AbsTypeModel -> TypeDecoderMap


-- | Conversion between ZM values in (simple, without field names) textual
--   form and the corresponding Haskell values
--   
--   <pre>
--   &gt;&gt;&gt; value 'a'
--   </pre>
module ZM.AsValue
class AsValue a
unVal :: AsValue a => String -> [Value] -> a
value :: forall a. (Model a, Flat a) => a -> Value
unValue :: AsValue a => Value -> a
instance ZM.AsValue.AsValue a => ZM.AsValue.AsValue (ZM.Type.Array.Array a)
instance ZM.AsValue.AsValue a => ZM.AsValue.AsValue (ZM.BLOB.BLOB a)
instance ZM.AsValue.AsValue ZM.Type.BLOB.NoEncoding
instance ZM.AsValue.AsValue ZM.Type.BLOB.FlatEncoding
instance ZM.AsValue.AsValue ZM.Type.BLOB.UTF8Encoding
instance ZM.AsValue.AsValue ZM.Type.BLOB.UTF16LEEncoding
instance ZM.AsValue.AsValue Data.Text.Internal.Text
instance ZM.AsValue.AsValue Data.Text.Internal.Lazy.Text
instance ZM.AsValue.AsValue Flat.Instances.Text.UTF8Text
instance ZM.AsValue.AsValue Flat.Instances.Text.UTF16Text
instance ZM.AsValue.AsValue Data.ByteString.Internal.ByteString
instance ZM.AsValue.AsValue Data.ByteString.Lazy.Internal.ByteString
instance ZM.AsValue.AsValue Data.ByteString.Short.Internal.ShortByteString
instance ZM.AsValue.AsValue ZM.Type.Array.Bytes
instance ZM.AsValue.AsValue a => ZM.AsValue.AsValue (Flat.Filler.PreAligned a)
instance ZM.AsValue.AsValue Flat.Filler.Filler
instance (ZM.AsValue.AsValue a, GHC.Classes.Ord a, ZM.AsValue.AsValue b) => ZM.AsValue.AsValue (Data.Map.Internal.Map a b)
instance ZM.AsValue.AsValue a => ZM.AsValue.AsValue (Data.Sequence.Internal.Seq a)
instance ZM.AsValue.AsValue ()
instance ZM.AsValue.AsValue GHC.Types.Char
instance ZM.AsValue.AsValue a => ZM.AsValue.AsValue [a]
instance ZM.AsValue.AsValue a => ZM.AsValue.AsValue (GHC.Maybe.Maybe a)
instance (ZM.AsValue.AsValue a, ZM.AsValue.AsValue b) => ZM.AsValue.AsValue (Data.Either.Either a b)
instance ZM.AsValue.AsValue GHC.Types.Bool
instance (ZM.AsValue.AsValue a1, ZM.AsValue.AsValue a2) => ZM.AsValue.AsValue (a1, a2)
instance (ZM.AsValue.AsValue a1, ZM.AsValue.AsValue a2, ZM.AsValue.AsValue a3) => ZM.AsValue.AsValue (a1, a2, a3)
instance (ZM.AsValue.AsValue a1, ZM.AsValue.AsValue a2, ZM.AsValue.AsValue a3, ZM.AsValue.AsValue a4) => ZM.AsValue.AsValue (a1, a2, a3, a4)
instance ZM.AsValue.AsValue ZM.Type.Words.Word7
instance ZM.AsValue.AsValue GHC.Word.Word8
instance ZM.AsValue.AsValue GHC.Word.Word16
instance ZM.AsValue.AsValue GHC.Word.Word32
instance ZM.AsValue.AsValue GHC.Word.Word64
instance ZM.AsValue.AsValue GHC.Types.Word
instance ZM.AsValue.AsValue GHC.Types.Int
instance ZM.AsValue.AsValue GHC.Natural.Natural
instance ZM.AsValue.AsValue GHC.Int.Int8
instance ZM.AsValue.AsValue GHC.Int.Int16
instance ZM.AsValue.AsValue GHC.Int.Int32
instance ZM.AsValue.AsValue GHC.Int.Int64
instance ZM.AsValue.AsValue GHC.Integer.Type.Integer
instance ZM.AsValue.AsValue GHC.Types.Float
instance ZM.AsValue.AsValue GHC.Types.Double
instance ZM.AsValue.AsValue ZM.Type.Words.Sign
instance ZM.AsValue.AsValue ZM.Type.Bit.Bit
instance ZM.AsValue.AsValue ZM.Type.Bits8.Bits8
instance ZM.AsValue.AsValue ZM.Type.Bits11.Bits11
instance ZM.AsValue.AsValue ZM.Type.Bits23.Bits23
instance ZM.AsValue.AsValue ZM.Type.Bits52.Bits52
instance ZM.AsValue.AsValue a => ZM.AsValue.AsValue (ZM.Type.Words.ZigZag a)
instance ZM.AsValue.AsValue a => ZM.AsValue.AsValue (ZM.Type.Words.LeastSignificantFirst a)
instance ZM.AsValue.AsValue a => ZM.AsValue.AsValue (ZM.Type.Words.MostSignificantFirst a)
instance ZM.AsValue.AsValue a => ZM.AsValue.AsValue (ZM.Type.NonEmptyList.NonEmptyList a)

module ZM.Parser.Lexer

-- | Space consumer |Removes spaces and haskell style line and block
--   comments "--.." "{- ..-}"
sc :: Parser ()
eof :: MonadParsec e s m => m ()

-- | <pre>
--   &gt;&gt;&gt; parseMaybe var "是不是"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe var "_"
--   Just Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe var "_a"
--   Just (Just "a")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe var "_是不是"
--   Just (Just "\26159\19981\26159")
--   </pre>
var :: Parser (Maybe String)
identifier :: Parser String
sym :: Parser String

-- | Parse a ZM localId (a unicode letter followed by zero or more unicode
--   alphanumeric characters or '_')
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe localId "*"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe localId "1"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe localId "A"
--   Just "A"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe localId "Gold金en"
--   Just "Gold\37329en"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe localId "是不是"
--   Just "\26159\19981\26159"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe localId "Bool -- a bool"
--   Just "Bool"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe localId "ant_13_"
--   Just "ant_13_"
--   </pre>
localId :: Parser String

-- | Parse a specific string
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe (symbol "=") ""
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe (symbol "=") "*"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe (symbol "=") "= -- an equal sign"
--   Just "="
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe (symbol "if then") "if then"
--   Just "if then"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe (symbol "Gold金en") "Gold金en"
--   Just "Gold\37329en"
--   </pre>
symbol :: String -> Parser String

-- | Parse signed floats or integers (as floats)
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe float "3"
--   Just 3.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe (float :: Parser Float)  "+3"
--   Just 3.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe (float :: Parser Double) "-3"
--   Just (-3.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe float "3.6E+11"
--   Just 3.6e11
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe float "-3.6E-11"
--   Just (-3.6e-11)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe float "-1E99999999"
--   Just (-Infinity)
--   </pre>
--   
--   Note: the decimal dot is not required
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe float "35"
--   Just 35.0
--   </pre>
float :: RealFloat a => Parser a

-- | <pre>
--   &gt;&gt;&gt; parseMaybe charLiteral "''"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe charLiteral " 'a'"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe charLiteral "'a' -- a comment"
--   Just 'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe charLiteral "'a'"
--   Just 'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe charLiteral "'\n'"
--   Just '\n'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe charLiteral "'金'"
--   Just '\37329'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe charLiteral "'\37329'"
--   Just '\37329'
--   </pre>
charLiteral :: Parser Char

-- | <pre>
--   &gt;&gt;&gt; parseMaybe stringLiteral "\"\""
--   Just ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe stringLiteral "\"abc\n金\37329\" "
--   Just "abc\n\37329\37329"
--   </pre>
stringLiteral :: Parser String

-- | Parse absolute reference's compact string format
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe shake "Ke45682c11f7b"
--   Just (SHAKE128_48 228 86 130 193 31 123)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe shake "KE45682C11F7B "
--   Just (SHAKE128_48 228 86 130 193 31 123)
--   </pre>
shake :: Parser (SHAKE128_48 a)

-- | @setup &gt;&gt;&gt; import Data.Int
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe signed "55" :: Maybe Int8
--   Just 55
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe signed "+55" :: Maybe Int8
--   Just 55
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe signed "-55" :: Maybe Int8
--   Just (-55)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe signed "+ 55" :: Maybe Int8
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe signed "- 55" :: Maybe Int8
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe signed "3455" :: Maybe Int16
--   Just 3455
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe signed "-4433455" :: Maybe Int32
--   Just (-4433455)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe signed "+231231231233455" :: Maybe Int64
--   Just 231231231233455
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe signed "-12312312" :: Maybe Int
--   Just (-12312312)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe signed "0xFF" :: Maybe Int8
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe signed "334559923200232302133331312313131231231231231231231" :: Maybe Integer
--   Just 334559923200232302133331312313131231231231231231231
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe signed "+334559923200232302133331312313131231231231231231231" :: Maybe Integer
--   Just 334559923200232302133331312313131231231231231231231
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe signed "-334559923200232302133331312313131231231231231231231" :: Maybe Integer
--   Just (-334559923200232302133331312313131231231231231231231)
--   </pre>
signed :: Integral a => Parser a

-- | @setup &gt;&gt;&gt; import Data.Word &gt;&gt;&gt; import
--   Numeric.Natural
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe unsigned "11" :: Maybe Word8
--   Just 11
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe unsigned "11." :: Maybe Word8
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe unsigned "33455" :: Maybe Word8
--   Just 175
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe unsigned "33455" :: Maybe Word16
--   Just 33455
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe unsigned "33455" :: Maybe Word32
--   Just 33455
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe unsigned "33455" :: Maybe Word64
--   Just 33455
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe unsigned "33455" :: Maybe Word
--   Just 33455
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe unsigned "334559923200232302133331312313131231231231231231231" :: Maybe Natural
--   Just 334559923200232302133331312313131231231231231231231
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe unsigned "+334559923200232302133331312313131231231231231231231" :: Maybe Natural
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe unsigned "-334559923200232302133331312313131231231231231231231" :: Maybe Natural
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe unsigned "0xFF" :: Maybe Word8
--   Just 255
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe unsigned "0XFF"
--   Just 255
--   </pre>
--   
--   TO ADD: parseMaybe unsigned
--   "334559923200232302131231321312312310103334045535353" :: Maybe Z.Word
--   Just 334559923200232302131231321312312310103334045535353
--   
--   parseMaybe unsigned "0" :: Maybe Word7 Just 0
--   
--   parseMaybe unsigned "0X7F" :: Maybe Word7 Just 127
--   
--   parseMaybe unsigned "0XFF" :: Maybe Word7 Nothing
unsigned :: Integral a => Parser a

module ZM.Parser.Util

-- | Parse a string using the provided parser
parseDoc :: Parser a -> String -> Either AtError a
mkAt :: SourcePos -> Int -> a2 -> Label Range a2
syntaxError :: (TraversableStream s, VisualStream s, ShowErrorComponent e) => ParseErrorBundle s e -> Label Range String

-- | Make the parser into a document parser (that will parse any initial
--   space and till eof)
doc :: Parser a -> Parser a

-- | Parses something between parenthesis "(..)"
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe (pars float) "()"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe (pars float) "( 3.7 )"
--   Just 3.7
--   </pre>
pars :: Parser a -> Parser a

-- | Parses something between curly parenthesis "{..}"
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe (cpars float) "{ 3.7 }"
--   Just 3.7
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe (cpars float) "{ 3.7 -- a number\n} -- curly stuff"
--   Just 3.7
--   </pre>
cpars :: Parser a -> Parser a

-- | Parses something between square parenthesis "[..]"
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe (spars float) "[3.7 ]"
--   Just 3.7
--   </pre>
spars :: Parser a -> Parser a

module ZM.Parser.Value

-- | Parse a plain ZM value.
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe value ""
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe value "_"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe value "_bv"
--   Nothing
--   </pre>
--   
--   Special syntax for numbers,chars,strings: &gt;&gt;&gt; parseMaybe
--   value "33" == Just (VInteger 33) True
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe value "-33" == Just (VInteger (-33))
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe value "-33.45" == Just (VFloat (-33.45))
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe value "3.3E-12" == Just (VFloat (3.3e-12))
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe value "-3.3E-12" == Just (VFloat (-3.3e-12))
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe value "'a'" == Just (VChar 'a')
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe value "((\"abc\"))" == Just (VString "abc")
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe value "False" == Just (Constr "False" (Left []))
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe value "(Cons False (Cons True Nil))" == Just (Constr "Cons" (Left [Constr "False" (Left []),Constr "Cons" (Left [Constr "True" (Left []),Constr "Nil" (Left [])])]))
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe value "Flag {val=True}" == Just (Constr "Flag" (Right [("val",Constr "True" (Left []))]))
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe value "T False \"abc\" (True) (N {name='g'})" == Just (Constr "T" (Left [Constr "False" (Left []),VString "abc",Constr "True" (Left []),Constr "N" (Right [("name",VChar 'g')])]))
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe value "T {left=False,right=X 'g' V0}" == Just (Constr "T" (Right [("left",Constr "False" (Left [])),("right",Constr "X" (Left [VChar 'g',Constr "V0" (Left [])]))]))
--   True
--   </pre>
--   
--   No type annotations: BAD &gt;&gt;&gt; parseMaybe value "False::Bool"
--   Nothing
value :: Parser Value

-- | Parse a pattern.
--   
--   A wildcard:
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe pattern "_ " == Just PWild
--   True
--   </pre>
--   
--   A named variable (variables must start with an _):
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe pattern "_A" == Just (PBind "A")
--   True
--   </pre>
--   
--   No pattern matching on constructor, a variable corresponds to a full
--   value:
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe pattern "_  Nil"
--   Nothing
--   </pre>
--   
--   Variables can appear at any level:
--   
--   <pre>
--   &gt;&gt;&gt; parse pattern "" "(T _ (T2  _b 'N'))" == Right (Constr "T" (Left [PWild,Constr "T2" (Left [PBind "b",VChar 'N'])]))
--   True
--   </pre>
pattern :: Parser Pattern

module ZM.Parser.Doc
data Section
Section :: String -> String -> Section
[name] :: Section -> String
[body] :: Section -> String
sectionText :: Section -> String
sectionsText :: [Section] -> String
data P b
P :: Parser a -> (a -> b) -> P b
[parser] :: P b -> Parser a
[converter] :: P b -> a -> b

-- | Document evaluation
--   
--   Variation: Section parsers, in addition of their content are also
--   given access to: * their context (the doc and their position in it) *
--   the parser itself so thaty can implement nested parsing. * a
--   read/write environment [(String,a)]
--   
--   {|This is some text with an embedded graph {dot ...} }
--   
--   <pre>
--   &gt;&gt;&gt; data R = AChar Char | AStr String deriving (Show)
--   
--   &gt;&gt;&gt; parsers = M.fromList [("char", AChar &lt;$&gt; charLiteral), ("$", AStr &lt;$&gt; stringLiteral)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parsers = M.fromList [("char", Left &lt;$&gt; charLiteral), ("$", Right &lt;$&gt; stringLiteral)]
--   
--   &gt;&gt;&gt; evalSections parsers "char 'c'\n$ \"abc\""
--   </pre>
evalSections :: Map String (Parser a) -> String -> Either String [a]
parseS :: Parser a -> String -> Either String a

-- | <pre>
--   &gt;&gt;&gt; parseMaybe sections "-- a comment\nadt Bool = False \n | True\nadt Enum = A \n   | B\n | C"
--   </pre>
--   
--   parseMaybe sections "adt Bool = False n | Truenadt Enum = A n | Bn |
--   C"
--   
--   <pre>
--   &gt;&gt;&gt; let src = "adt Bool = False \n | True\nadt Enum = A \n   | B\n | C" in (\ss -&gt; src == sectionsText ss) &lt;$&gt; (parseMaybe sectionsDoc src)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe sectionsDoc "\n  abc \nadt Bool = False \n| True\nadt Enum = A \n   | B\n | C"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe sectionsDoc "\n \t \r\n \nadt Bool = False \n| True\nadt Enum = A \n   | B\n | C"
--   </pre>
sections :: Parser [Section]

-- | <pre>
--   &gt;&gt;&gt; let src = "adt Bool = False \n | True\nadt Enum = A \n   | B\n | C" in (\ss -&gt; src == sectionsText ss) &lt;$&gt; (parseMaybe sectionsDoc src)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe sectionsDoc "\n  abc \nadt Bool = False \n| True\nadt Enum = A \n   | B\n | C"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe sectionsDoc "\n \t \r\n \nadt Bool = False \n| True\nadt Enum = A \n   | B\n | C"
--   </pre>
sectionsDoc :: Parser [Section]

-- | <pre>
--   &gt;&gt;&gt; parseMaybe section "adt"
--   Just (Section {name = "adt", body = ""})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe section "adt    Bool = False | True"
--   Just (Section {name = "adt", body = "Bool = False | True"})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe section "adt Enum = A \n   | B\n | C"
--   Just (Section {name = "adt", body = "Enum = A \n   | B\n | C"})
--   </pre>
section :: Parser Section
sectionBody :: Parser String
sectionEnd :: Parser ()
elems :: ParsecT Void String Identity [Either String [Char]]
anyChar :: Parser Char

-- | <pre>
--   &gt;&gt;&gt; parseMaybe sectionName " adt"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe sectionName "adt"
--   Just "adt"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe sectionName "-()[]{}"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe sectionName ":+*/.@#$%?&gt;&lt;;"
--   Just ":+*/.@#$%?&gt;&lt;;"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe sectionName "_"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe sectionName "{"
--   </pre>
sectionName :: Parser String
isNameChar :: Char -> Bool

-- | <pre>
--   &gt;&gt;&gt; parseMaybe skipEmptyLines ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe skipEmptyLines "\n   \t  \n"
--   Just ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe skipEmptyLines "\n "
--   Nothing
--   </pre>
skipEmptyLines :: Parser ()
skipEmptyLine :: Parser ()
instance GHC.Show.Show ZM.Parser.Doc.Section

module ZM.Parser.ADT

-- | Parse a, possibly empty, group of ZM ADT declarations.
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe adts ""
--   Just []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr $ prettyShow $ parseMaybe adts "Void;"
--   Just [Void@(0:0-3) =]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr $ prettyShow $ parseMaybe adts "Void;Bool=False | True"
--   Just [Void@(0:0-3) =,
--         Bool@(0:5-8) = False@(0:10-14) | True@(0:18-21)]
--   </pre>
adts :: Parser [ADTParts]

-- | Parse a ZM ADT declaration.
--   
--   <pre>
--   &gt;&gt;&gt; putStr $ prettyShow $ parseMaybe adt "Void"
--   Just Void@(0:0-3) =
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr $ prettyShow $ parseMaybe adt "Bool.K306f1981b41c = False \n| True"
--   Just Bool.K306f1981b41c@(0:0-17) = False@(0:21-25) | True@(1:2-5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr $ prettyShow $ parseMaybe adt "是不是 ≡   是\n                    | 不是"
--   Just 是不是@(0:0-2) = 是@(0:8) | 不是@(1:22-23)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr $ prettyShow $ parseMaybe adt "A = A (A (B C D))"
--   Just A@(0:0) = A@(0:4) (A@(0:7) (B@(0:10) C@(0:12) D@(0:14)))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr $ prettyShow $ parseMaybe adt "Msg = Msg {from:Name.K306f1981b41c,subject:String}"
--   Just Msg@(0:0-2) = Msg@(0:6-8) {from@(0:11-14) :: Name.K306f1981b41c@(0:16-33),
--                                   subject@(0:35-41) :: String@(0:43-48)}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr $ prettyShow $ parseMaybe adt "List a = Cons {head:a, tail:List a} | \nNil"
--   Just List@(0:0-3) a@(0:5) = Cons@(0:9-12) {head@(0:15-18) :: a@(0:20),
--                                              tail@(0:23-26) :: List@(0:28-31) a@(0:33)} | Nil@(1:0-2)
--   </pre>
--   
--   Syntax Errors:
--   
--   <pre>
--   &gt;&gt;&gt; putStr $ prettyShow $ parseDoc adt "Bool = | True"
--   Left "unexpected '|' expecting end of input or letter"@(0:7)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr $ prettyShow $ parseDoc adt " = "
--   Left "unexpected '=' expecting letter"@(0:1)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr $ prettyShow $ parseDoc adt "a b.d e.f = c.f.a"
--   Left "unexpected '.' expecting '=', '_', '\8801', alphanumeric character, end of input, or letter"@(0:3)
--   </pre>
adt :: Parser ADTParts

-- | Parse a type application, a type constructor with zero or more
--   parameters
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe (parType localId) "a"
--   Just (TypeCon "a")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe (parType localId) "((a))"
--   Just (TypeCon "a")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe (parType localId) "a b"
--   Just (TypeApp (TypeCon "a") (TypeCon "b"))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe (parType localId) "(a) ((b)) c"
--   Just (TypeApp (TypeApp (TypeCon "a") (TypeCon "b")) (TypeCon "c"))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; typeN &lt;$&gt; parseMaybe (parType localId) "(a b (c d (e f g))) z"
--   Just (TypeN "a" [TypeN "b" [],TypeN "c" [TypeN "d" [],TypeN "e" [TypeN "f" [],TypeN "g" []]],TypeN "z" []])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe (parType localId) "(a b) c"
--   Just (TypeApp (TypeApp (TypeCon "a") (TypeCon "b")) (TypeCon "c"))
--   </pre>
parType :: Parser a -> Parser (Type a)

-- | <pre>
--   &gt;&gt;&gt; prettyShow &lt;$&gt; parseMaybe absReference "K306f1981b41c"
--   Just "K306f1981b41c"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; prettyShow &lt;$&gt; parseMaybe absReference "KKK"
--   Nothing
--   </pre>
absReference :: Parser AbsRef

-- | <pre>
--   &gt;&gt;&gt; prettyShow &lt;$&gt; parseMaybe maybeNamedAbsRef "Bool.K306f1981b41c"
--   Just "Bool.K306f1981b41c"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; prettyShow &lt;$&gt; parseMaybe maybeNamedAbsRef ".K306f1981b41c"
--   Just ".K306f1981b41c"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; prettyShow &lt;$&gt; parseMaybe maybeNamedAbsRef "K306f1981b41c"
--   Just ".K306f1981b41c"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; prettyShow &lt;$&gt; parseMaybe maybeNamedAbsRef "Bool"
--   Nothing
--   </pre>
maybeNamedAbsRef :: Parser (TypeName Identifier)

-- | Parse a simple type name, possibly qualified with an absolute code.
--   
--   <pre>
--   &gt;&gt;&gt; prettyShow &lt;$&gt; parseMaybe namedOrAbsRef "nil"
--   Just "nil"
--   </pre>
--   
--   The . is required to distinguish a hash from a plain type name (remove
--   this ambiguity?)
--   
--   This is a hash:
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe namedOrAbsRef ".K306f1981b41c"
--   Just (That (AbsRef (SHAKE128_48 48 111 25 129 180 28)))
--   </pre>
--   
--   And this is just a type name (NO actually we try to interpret it as an
--   absolute reference first):
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe namedOrAbsRef "K306f1981b41c"
--   Just (That (AbsRef (SHAKE128_48 48 111 25 129 180 28)))
--   </pre>
namedOrAbsRef :: Parser (TypeName Identifier)

module ZM.To.Encoder

-- | Return a Flat encoder for values of the ZM type corresponding to the
--   provided Haskell type
encoderFor :: Model a => Proxy a -> ParserEncoder

-- | Return a Flat encoder for values of the provided ZM type
typeEncoder :: AbsTypeModel -> ParserEncoder
instance Flat.Class.Flat ZM.To.Encoder.OBJ

module ZM.Parser.Env

-- | Parse a (possibly empty) closed group of ADT declarations.
--   
--   <pre>
--   &gt;&gt;&gt; tst = putStr . prettyShow . parseADTs
--   
--   &gt;&gt;&gt; ok = putStr . prettyShow . (\(Right a) -&gt; a) . parseADTs
--   </pre>
--   
--   Empty declarations are ok:
--   
--   <pre>
--   &gt;&gt;&gt; parseADTs ""
--   Right (fromList [])
--   </pre>
--   
--   Line comments are introduced by `--`:
--   
--   <pre>
--   &gt;&gt;&gt; parseADTs "-- Nothing to see here"
--   Right (fromList [])
--   </pre>
--   
--   ZM datatype definitions are very similar to Haskell's.
--   
--   There is no initial `data` keyword, so to define an empty data type
--   just state its name:
--   
--   <pre>
--   &gt;&gt;&gt; ok "Void"
--   Void.Kf4165614d4f2 ;
--   </pre>
--   
--   Every data type has an (almost) unique absolute reference, for
--   <a>Void</a> is <tt>Kf4165614d4f2</tt>.
--   
--   The reference can be explicitly stated:
--   
--   <pre>
--   &gt;&gt;&gt; ok "Void.Kf4165614d4f2"
--   Void.Kf4165614d4f2 ;
--   </pre>
--   
--   Cannot have names wih multiple parts: &gt;&gt;&gt; tst
--   "a.really.bad.adt.name" Left ["unexpected <tt>r</tt> expecting
--   <tt>K</tt>"@(0:2)]
--   
--   Names of both data types and constructors start with a unicode letter
--   (upper or lowercase) followed by zero or more letters and numbers (but
--   no symbols):
--   
--   <pre>
--   &gt;&gt;&gt; ok "bool"
--   bool.K4badcbf6aefb ;
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ok "是 -- chinese characters are fine too!"
--   是.K086ea5f1306b ;
--   </pre>
--   
--   Unicode symbols are not allowed:
--   
--   <pre>
--   &gt;&gt;&gt; tst "&lt;&gt;"
--   Left ["unexpected '&lt;' expecting end of input or letter"@(0:0)]
--   </pre>
--   
--   A data type can have zero or more constructors, separated by a `|`:
--   
--   <pre>
--   &gt;&gt;&gt; ok "bool = false | true"
--   bool.Kb61fc3993fd1 ≡   false
--                        | true;
--   </pre>
--   
--   Constructor names must be unique:
--   
--   <pre>
--   &gt;&gt;&gt; tst "T = C1 | C1 | C2 | C3 | C3"
--   Left ["Duplicated constructor: C1"@(0:9-10),
--         "Duplicated constructor: C3"@(0:24-25)]
--   </pre>
--   
--   Blank space is allowed, no special indentation is required:
--   
--   <pre>
--   &gt;&gt;&gt; ok "是不是 ≡   是\n |\n \n \t 不是;"
--   是不是.Ka0df1ad8aa92 ≡   是
--   ...               | 不是;
--   </pre>
--   
--   Constructors can have named fields.
--   
--   Field types can be introduced by either ":" or "::"
--   
--   <pre>
--   &gt;&gt;&gt; tst "Bool = False|True;Id = A | B;Switch = Switch {name::Id,state:Bool}"
--   Right Bool.K306f1981b41c ≡   False
--                              | True;
--   
--         Id.K7e20ca15902f ≡   A
--                            | B;
--   
--         Switch.Kcd5467075768 ≡   Switch {name :: Id.K7e20ca15902f,
--                                          state :: Bool.K306f1981b41c};
--   </pre>
--   
--   Multiple fields with a single type signature are not supported
--   
--   <pre>
--   &gt;&gt;&gt; tst "Id = A | B;Ids = Ids {id0,id1:Id}"
--   Left ["unexpected \",i\" expecting \"::\", ':', '_', or alphanumeric character"@(0:25)]
--   </pre>
--   
--   A data type can have zero or more type variables:
--   
--   <pre>
--   &gt;&gt;&gt; ok "Maybe a = Nothing | Just a"
--   Maybe.Kda6836778fd4 a ≡   Nothing
--                           | Just a;
--   </pre>
--   
--   Variable names must be unique and different from the data type name:
--   
--   <pre>
--   &gt;&gt;&gt; tst "list a list a = nil"
--   Left ["Duplicated type name: list"@(0:7-10),
--         "Duplicated type name: a"@(0:12)]
--   </pre>
--   
--   Contructor names must be unique &gt;&gt;&gt; tst "DupConstructors = a
--   | a | b | c | b" Left ["Duplicated constructor: a"<tt>(0:22),
--   "Duplicated constructor: b"</tt>(0:34)]
--   
--   Phantom type variables (variables that are declared but not used in
--   the constructors) are ok:
--   
--   <pre>
--   &gt;&gt;&gt; tst $ "P phantom ≡ P"
--   Right P.K76cc89d4c46f a ≡   P;
--   </pre>
--   
--   Self-recursion is ok:
--   
--   <pre>
--   &gt;&gt;&gt; tst $ "List a = Cons a (List a) | Nil"
--   Right List.Kb8207ed4e169 a ≡   Cons a (List.Kb8207ed4e169 a)
--                                | Nil;
--   </pre>
--   
--   Multiple data types definitions are separated by semicolumns:
--   
--   <pre>
--   &gt;&gt;&gt; tst $ "Void;Bool = False | True"
--   Right Bool.K306f1981b41c ≡   False
--                              | True;
--   
--         Void.Kf4165614d4f2 ;
--   </pre>
--   
--   Source must be syntactically correct:
--   
--   <pre>
--   &gt;&gt;&gt; tst "Bad !"
--   Left ["unexpected '!' expecting '.', ';', '=', '\8801', end of input, or letter"@(0:4)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tst "a = |"
--   Left ["unexpected '|' expecting ';', end of input, or letter"@(0:4)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tst "= ="
--   Left ["unexpected '=' expecting end of input or letter"@(0:0)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tst "a b.d = c.f"
--   Left ["unexpected '.' expecting ';', '=', '_', '\8801', alphanumeric character, end of input, or letter"@(0:3)]
--   </pre>
--   
--   All references must be resolvable.
--   
--   Local references must resolve to an adt variable or a locally named
--   type:
--   
--   <pre>
--   &gt;&gt;&gt; tst "T = T a Bool"
--   Left ["Reference to unknown type: a"@(0:6),
--         "Reference to unknown type: Bool"@(0:8-11)]
--   </pre>
--   
--   If multiple type declarations with the same name are present, only the
--   last one is used:
--   
--   <pre>
--   &gt;&gt;&gt; tst $ "Void;A = A Void;Void = V;B = B Void"
--   Right A.K3a8a7ea9f77c ≡   A Void.K498d6de22d87;
--   
--         B.K531b1a37d8d8 ≡   B Void.K498d6de22d87;
--   
--         Void.K498d6de22d87 ≡   V;
--   </pre>
--   
--   But you can add an (unckecked) K suffix to distinguish them:
--   
--   <pre>
--   &gt;&gt;&gt; tst $ "Void.Kf4165614d4f2;A = VV Void.K498d6de22d87 | V Void.Kf4165614d4f2;Void.K498d6de22d87 = V;"
--   Right A.K3d3bca29bc26 ≡   VV Void.K498d6de22d87
--                           | V Void.Kf4165614d4f2;
--   
--         Void.Kf4165614d4f2 ;
--   
--         Void.K498d6de22d87 ≡   V;
--   </pre>
--   
--   Type constructors are fully applied:
--   
--   <pre>
--   &gt;&gt;&gt; tst "Either a b = Left a | Right b;T a = T (Either a)"
--   Left ["Incorrect application of Either, should have 2 parameters but has 1"@(0:39-44)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tst "Bool = False;Maybe a = Just a | Nothing;Either a b = Left a | Right b;G g = g g;T a = T (Either (Maybe a) (Either (Maybe a) Bool Maybe))"
--   Left ["Incorrect application of Either, should have 2 parameters but has 3"@(0:107-112),
--         "Incorrect application of Maybe, should have 1 parameters but has 0"@(0:129-133)]
--   </pre>
--   
--   No higher kinds (all variables are assumed to be fully applied data
--   types):
--   
--   <pre>
--   &gt;&gt;&gt; tst "Free f a = Pure a | Free (f (Free f a))"
--   Left ["Incorrect application of f, should have 0 parameters but has 1"@(0:26)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tst "Fix f a = Fix (f a)"
--   Left ["Incorrect application of f, should have 0 parameters but has 1"@(0:15)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tst "FixR f a = FixR (f (f a))"
--   Left ["Incorrect application of f, should have 0 parameters but has 1"@(0:17),
--         "Incorrect application of f, should have 0 parameters but has 1"@(0:20)]
--   </pre>
--   
--   No mutually recursive definitions:
--   
--   <pre>
--   &gt;&gt;&gt; tst "A = A B;B = B A;C = C D;D = D C A"
--   Left ["Found mutually recursive types: [D, C]"@(0:22),
--         "Found mutually recursive types: [D, C]"@(0:16),
--         "Found mutually recursive types: [B, A]"@(0:6),
--         "Found mutually recursive types: [B, A]"@(0:0)]
--   </pre>
--   
--   We try to capture as many errors as possible at the same time:
--   
--   <pre>
--   &gt;&gt;&gt; tst "T a a b T = C1 | C1 | C2 | C3 | C2 | T "
--   Left ["Duplicated type name: a"@(0:4),
--         "Duplicated type name: T"@(0:8),
--         "Duplicated constructor: C1"@(0:17-18),
--         "Duplicated constructor: C2"@(0:32-33)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tst "List List ≡ Nil"
--   Left ["Duplicated type name: List"@(0:5-8)]
--   </pre>
parseADTs :: String -> Either [AtError] AbsEnv

-- | Parse a (possibly empty) group of ADT declarations, in the context of
--   an environment.
--   
--   An environment with definitions for Bool and List:
--   
--   <pre>
--   &gt; prettyShow $ absEnv (Proxy :: Proxy [Bool])
--   </pre>
--   
--   <pre>
--   &gt; parseADTsWith (absEnv (Proxy :: Proxy [Bool])) $ "T = T (List.Kb8cd13187198 Bool.K306f1981b41c)"
--   </pre>
--   
--   <pre>
--   &gt; :{
--   </pre>
--   
--   let env = absEnv (Proxy :: Proxy [Bool]) in putStr . prettyShow .
--   parseADTsWith (absEnv (Proxy :: Proxy [Bool])) $ unlines [ " -- We
--   refer to two external absolute types" ,"T = T (List.Kb8cd13187198
--   Bool.K306f1981b41c)" ] :} Right Bool.K306f1981b41c ≡ False | True; ...
--   List.Kb8cd13187198 a ≡ Nil | Cons a (List.Kb8cd13187198 a); ...
--   T.K63f0354d9548 ≡ T (List.Kb8cd13187198 Bool.K306f1981b41c);
--   
--   If a type is defined locally it should be referred to with a local
--   reference, not an absolute one: NOT REALLY.
--   
--   <pre>
--   &gt; putStr . prettyShow . parseADTsWith (absEnv (Proxy :: Proxy Bool)) $ "T = T Bool.K306f1981b41c;Bool = False | True"
--   </pre>
--   
--   Remote references to correct types are retrieved and checked:
--   
--   <pre>
--   &gt; tst "T = T Bool.K306f1981b41c"
--   </pre>
--   
--   BAD: Left ["Reference to unknown type: Bool.K306f1981b41c"@(0:6-23)]
parseADTsWith :: AbsEnv -> String -> Either [AtError] AbsEnv
instance ZM.Abs.KeyOf (ZM.Parser.Types.At (ZM.Parser.Types.TypeName ZM.Types.Identifier)) (ZM.Types.AbsRef, ZM.Types.AbsADT)

module ZM.Parser
parseMaybe :: (Ord e, Stream s) => Parsec e s a -> s -> Maybe a
parseErrorPretty :: (VisualStream s, ShowErrorComponent e) => ParseError s e -> String
