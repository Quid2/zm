<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE FlexibleContexts          #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE FlexibleInstances         #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# LANGUAGE MultiParamTypeClasses     #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# LANGUAGE NoMonomorphismRestriction #-}</span><span>
</span><span id="line-5"></span><span>
</span><span id="line-6"></span><span class="hs-comment">-- Parse ZM data type definitions</span><span>
</span><span id="line-7"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">ZM.Parser.Env</span><span>
</span><span id="line-8"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="ZM.Parser.Env.html#parseADTs"><span class="hs-identifier">parseADTs</span></a></span><span>
</span><span id="line-9"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="ZM.Parser.Env.html#parseADTsWith"><span class="hs-identifier">parseADTsWith</span></a></span><span>
</span><span id="line-10"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-11"></span><span>
</span><span id="line-12"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="ZM.Parser.ADT.html"><span class="hs-identifier">ZM.Parser.ADT</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="ZM.Parser.ADT.html#adts"><span class="hs-identifier">adts</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-13"></span><span>
</span><span id="line-14"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Either</span></span><span>
</span><span id="line-15"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.List</span></span><span>
</span><span id="line-16"></span><span>
</span><span id="line-17"></span><span class="hs-comment">-- import           Data.Maybe</span><span>
</span><span id="line-18"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="ZM.Parser.Types.html"><span class="hs-identifier">ZM.Parser.Types</span></a></span><span>
</span><span id="line-19"></span><span>
</span><span id="line-20"></span><span class="hs-comment">-- import qualified ZM.Parser.Parser as P</span><span>
</span><span id="line-21"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="ZM.Parser.Util.html"><span class="hs-identifier">ZM.Parser.Util</span></a></span><span>
</span><span id="line-22"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="ZM.Pretty.html"><span class="hs-identifier">ZM.Pretty</span></a></span><span>
</span><span id="line-23"></span><span>
</span><span id="line-24"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Control.Monad</span></span><span>
</span><span id="line-25"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Bifunctor</span></span><span>
</span><span id="line-26"></span><span>
</span><span id="line-27"></span><span class="hs-comment">--import Data.Either.Extra</span><span>
</span><span id="line-28"></span><span class="hs-comment">-- import           Data.Either.Validation</span><span>
</span><span id="line-29"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Foldable</span></span><span>
</span><span id="line-30"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Map</span></span><span>        </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">M</span></span><span>
</span><span id="line-31"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Model</span></span><span>
</span><span id="line-32"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Word</span></span><span>
</span><span id="line-33"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="ZM.Abs.html"><span class="hs-identifier">ZM.Abs</span></a></span><span>
</span><span id="line-34"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="ZM.Types.html"><span class="hs-identifier">ZM.Types</span></a></span><span>
</span><span id="line-35"></span><span>
</span><span id="line-36"></span><span class="hs-comment">-- tst = putStr . prettyShow . parseADTs</span><span>
</span><span id="line-37"></span><span class="hs-comment">-- ok = putStr . prettyShow . (\(Right a) -&gt; a) . parseADTs</span><span>
</span><span id="line-38"></span><span class="hs-comment">-- import           ZM.Util</span><span>
</span><span id="line-39"></span><span class="hs-comment">{-|
Parse a (possibly empty) closed group of ADT declarations.

&gt;&gt;&gt; tst = putStr . prettyShow . parseADTs
&gt;&gt;&gt; ok = putStr . prettyShow . (\(Right a) -&gt; a) . parseADTs

Empty declarations are ok:

&gt;&gt;&gt; parseADTs &quot;&quot;
Right (fromList [])

Line comments are introduced by `--`:

&gt;&gt;&gt; parseADTs &quot;-- Nothing to see here&quot;
Right (fromList [])

ZM datatype definitions are very similar to Haskell's.

There is no initial `data` keyword, so to define an empty data type just state its name:

&gt;&gt;&gt; ok &quot;Void&quot;
Void.Kf4165614d4f2 ;

Every data type has an (almost) unique absolute reference, for `Void` is `Kf4165614d4f2`.

The reference can be explicitly stated:

&gt;&gt;&gt; ok &quot;Void.Kf4165614d4f2&quot;
Void.Kf4165614d4f2 ;

Cannot have names wih multiple parts:
&gt;&gt;&gt; tst &quot;a.really.bad.adt.name&quot;
Left [&quot;unexpected 'r' expecting 'K'&quot;@(0:2)]

Names of both data types and constructors start with a unicode letter (upper or lowercase) followed by zero or more letters and numbers (but no symbols):

&gt;&gt;&gt; ok &quot;bool&quot;
bool.K4badcbf6aefb ;

&gt;&gt;&gt; ok &quot;&#26159; -- chinese characters are fine too!&quot;
&#26159;.K086ea5f1306b ;

Unicode symbols are not allowed:

&gt;&gt;&gt; tst &quot;&lt;&gt;&quot;
Left [&quot;unexpected '&lt;' expecting end of input or letter&quot;@(0:0)]

A data type can have zero or more constructors, separated by a `|`:

&gt;&gt;&gt; ok &quot;bool = false | true&quot;
bool.Kb61fc3993fd1 &#8801;   false
                     | true;

Constructor names must be unique:

&gt;&gt;&gt; tst &quot;T = C1 | C1 | C2 | C3 | C3&quot;
Left [&quot;Duplicated constructor: C1&quot;@(0:9-10),
      &quot;Duplicated constructor: C3&quot;@(0:24-25)]

Blank space is allowed, no special indentation is required:

&gt;&gt;&gt; ok &quot;&#26159;&#19981;&#26159; &#8801;   &#26159;\n |\n \n \t &#19981;&#26159;;&quot;
&#26159;&#19981;&#26159;.Ka0df1ad8aa92 &#8801;   &#26159;
...               | &#19981;&#26159;;

Constructors can have named fields.

Field types can be introduced by either &quot;:&quot; or &quot;::&quot;

&gt;&gt;&gt; tst &quot;Bool = False|True;Id = A | B;Switch = Switch {name::Id,state:Bool}&quot;
Right Bool.K306f1981b41c &#8801;   False
                           | True;
&lt;BLANKLINE&gt;
      Id.K7e20ca15902f &#8801;   A
                         | B;
&lt;BLANKLINE&gt;
      Switch.Kcd5467075768 &#8801;   Switch {name :: Id.K7e20ca15902f,
                                       state :: Bool.K306f1981b41c};

Multiple fields with a single type signature are not supported

&gt;&gt;&gt; tst &quot;Id = A | B;Ids = Ids {id0,id1:Id}&quot;
Left [&quot;unexpected \&quot;,i\&quot; expecting \&quot;::\&quot;, ':', '_', or alphanumeric character&quot;@(0:25)]

A data type can have zero or more type variables:

&gt;&gt;&gt; ok &quot;Maybe a = Nothing | Just a&quot;
Maybe.Kda6836778fd4 a &#8801;   Nothing
                        | Just a;

Variable names must be unique and different from the data type name:

&gt;&gt;&gt; tst &quot;list a list a = nil&quot;
Left [&quot;Duplicated type name: list&quot;@(0:7-10),
      &quot;Duplicated type name: a&quot;@(0:12)]

Contructor names must be unique
&gt;&gt;&gt; tst &quot;DupConstructors = a | a | b | c | b&quot;
Left [&quot;Duplicated constructor: a&quot;@(0:22),
      &quot;Duplicated constructor: b&quot;@(0:34)]

Phantom type variables (variables that are declared but not used in the constructors) are ok:

&gt;&gt;&gt; tst $ &quot;P phantom &#8801; P&quot;
Right P.K76cc89d4c46f a &#8801;   P;


Self-recursion is ok:

&gt;&gt;&gt; tst $ &quot;List a = Cons a (List a) | Nil&quot;
Right List.Kb8207ed4e169 a &#8801;   Cons a (List.Kb8207ed4e169 a)
                             | Nil;

Multiple data types definitions are separated by semicolumns:

&gt;&gt;&gt; tst $ &quot;Void;Bool = False | True&quot;
Right Bool.K306f1981b41c &#8801;   False
                           | True;
&lt;BLANKLINE&gt;
      Void.Kf4165614d4f2 ;

Source must be syntactically correct:

&gt;&gt;&gt; tst &quot;Bad !&quot;
Left [&quot;unexpected '!' expecting '.', ';', '=', '\8801', end of input, or letter&quot;@(0:4)]

&gt;&gt;&gt; tst &quot;a = |&quot;
Left [&quot;unexpected '|' expecting ';', end of input, or letter&quot;@(0:4)]

&gt;&gt;&gt; tst &quot;= =&quot;
Left [&quot;unexpected '=' expecting end of input or letter&quot;@(0:0)]

&gt;&gt;&gt; tst &quot;a b.d = c.f&quot;
Left [&quot;unexpected '.' expecting ';', '=', '_', '\8801', alphanumeric character, end of input, or letter&quot;@(0:3)]

All references must be resolvable.

Local references must resolve to an adt variable or a locally named type:

&gt;&gt;&gt; tst &quot;T = T a Bool&quot;
Left [&quot;Reference to unknown type: a&quot;@(0:6),
      &quot;Reference to unknown type: Bool&quot;@(0:8-11)]

If multiple type declarations with the same name are present, only the last one is used:

&gt;&gt;&gt; tst $ &quot;Void;A = A Void;Void = V;B = B Void&quot;
Right A.K3a8a7ea9f77c &#8801;   A Void.K498d6de22d87;
&lt;BLANKLINE&gt;
      B.K531b1a37d8d8 &#8801;   B Void.K498d6de22d87;
&lt;BLANKLINE&gt;
      Void.K498d6de22d87 &#8801;   V;

But you can add an (unckecked) K suffix to distinguish them:

&gt;&gt;&gt; tst $ &quot;Void.Kf4165614d4f2;A = VV Void.K498d6de22d87 | V Void.Kf4165614d4f2;Void.K498d6de22d87 = V;&quot;
Right A.K3d3bca29bc26 &#8801;   VV Void.K498d6de22d87
                        | V Void.Kf4165614d4f2;
&lt;BLANKLINE&gt;
      Void.Kf4165614d4f2 ;
&lt;BLANKLINE&gt;
      Void.K498d6de22d87 &#8801;   V;

Type constructors are fully applied:

&gt;&gt;&gt; tst &quot;Either a b = Left a | Right b;T a = T (Either a)&quot;
Left [&quot;Incorrect application of Either, should have 2 parameters but has 1&quot;@(0:39-44)]

&gt;&gt;&gt; tst &quot;Bool = False;Maybe a = Just a | Nothing;Either a b = Left a | Right b;G g = g g;T a = T (Either (Maybe a) (Either (Maybe a) Bool Maybe))&quot;
Left [&quot;Incorrect application of Either, should have 2 parameters but has 3&quot;@(0:107-112),
      &quot;Incorrect application of Maybe, should have 1 parameters but has 0&quot;@(0:129-133)]

No higher kinds (all variables are assumed to be fully applied data types):

&gt;&gt;&gt; tst &quot;Free f a = Pure a | Free (f (Free f a))&quot;
Left [&quot;Incorrect application of f, should have 0 parameters but has 1&quot;@(0:26)]

&gt;&gt;&gt; tst &quot;Fix f a = Fix (f a)&quot;
Left [&quot;Incorrect application of f, should have 0 parameters but has 1&quot;@(0:15)]

&gt;&gt;&gt; tst &quot;FixR f a = FixR (f (f a))&quot;
Left [&quot;Incorrect application of f, should have 0 parameters but has 1&quot;@(0:17),
      &quot;Incorrect application of f, should have 0 parameters but has 1&quot;@(0:20)]

No mutually recursive definitions:

&gt;&gt;&gt; tst &quot;A = A B;B = B A;C = C D;D = D C A&quot;
Left [&quot;Found mutually recursive types: [D, C]&quot;@(0:22),
      &quot;Found mutually recursive types: [D, C]&quot;@(0:16),
      &quot;Found mutually recursive types: [B, A]&quot;@(0:6),
      &quot;Found mutually recursive types: [B, A]&quot;@(0:0)]

We try to capture as many errors as possible at the same time:

&gt;&gt;&gt; tst &quot;T a a b T = C1 | C1 | C2 | C3 | C2 | T &quot;
Left [&quot;Duplicated type name: a&quot;@(0:4),
      &quot;Duplicated type name: T&quot;@(0:8),
      &quot;Duplicated constructor: C1&quot;@(0:17-18),
      &quot;Duplicated constructor: C2&quot;@(0:32-33)]


&gt;&gt;&gt; tst &quot;List List &#8801; Nil&quot;
Left [&quot;Duplicated type name: List&quot;@(0:5-8)]

-}</span><span>
</span><span id="line-243"></span><span class="annot"><a href="ZM.Parser.Env.html#parseADTs"><span class="hs-identifier hs-type">parseADTs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="ZM.Parser.Types.html#AtError"><span class="hs-identifier hs-type">AtError</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="ZM.Types.html#AbsEnv"><span class="hs-identifier hs-type">AbsEnv</span></a></span><span>
</span><span id="line-244"></span><span id="parseADTs"><span class="annot"><span class="annottext">parseADTs :: String -&gt; Either [AtError] AbsEnv
</span><a href="ZM.Parser.Env.html#parseADTs"><span class="hs-identifier hs-var hs-var">parseADTs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">AbsEnv -&gt; String -&gt; Either [AtError] AbsEnv
</span><a href="ZM.Parser.Env.html#parseADTsWith"><span class="hs-identifier hs-var">parseADTsWith</span></a></span><span> </span><span class="annot"><span class="annottext">AbsEnv
forall k a. Map k a
</span><span class="hs-identifier hs-var">M.empty</span></span><span>
</span><span id="line-245"></span><span>
</span><span id="line-246"></span><span class="hs-comment">{-|
Parse a (possibly empty) group of ADT declarations, in the context of an environment.


An environment with definitions for Bool and List:

&gt;&gt; prettyShow $ absEnv (Proxy :: Proxy [Bool])

&gt;&gt; parseADTsWith (absEnv (Proxy :: Proxy [Bool])) $ &quot;T = T (List.Kb8cd13187198 Bool.K306f1981b41c)&quot;

&gt;&gt; :{
      let env = absEnv (Proxy :: Proxy [Bool])
      in putStr . prettyShow . parseADTsWith (absEnv (Proxy :: Proxy [Bool])) $
         unlines [ &quot; -- We refer to two external absolute types&quot;
                  ,&quot;T = T (List.Kb8cd13187198 Bool.K306f1981b41c)&quot;
                  ]
:}
Right Bool.K306f1981b41c &#8801;   False
                            | True;
...
      List.Kb8cd13187198 a &#8801;   Nil
                              | Cons a (List.Kb8cd13187198 a);
...
      T.K63f0354d9548 &#8801;   T (List.Kb8cd13187198 Bool.K306f1981b41c);

If a type is defined locally it should be referred to with a local reference, not an absolute one:
NOT REALLY.

&gt;&gt; putStr . prettyShow . parseADTsWith (absEnv (Proxy :: Proxy Bool)) $ &quot;T = T Bool.K306f1981b41c;Bool = False | True&quot;


Remote references to correct types are retrieved and checked:

&gt;&gt; tst &quot;T = T Bool.K306f1981b41c&quot;
BAD: Left [&quot;Reference to unknown type: Bool.K306f1981b41c&quot;@(0:6-23)]

-}</span><span>
</span><span id="line-283"></span><span class="annot"><a href="ZM.Parser.Env.html#parseADTsWith"><span class="hs-identifier hs-type">parseADTsWith</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="ZM.Types.html#AbsEnv"><span class="hs-identifier hs-type">AbsEnv</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="ZM.Parser.Types.html#AtError"><span class="hs-identifier hs-type">AtError</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="ZM.Types.html#AbsEnv"><span class="hs-identifier hs-type">AbsEnv</span></a></span><span>
</span><span id="line-284"></span><span id="parseADTsWith"><span class="annot"><span class="annottext">parseADTsWith :: AbsEnv -&gt; String -&gt; Either [AtError] AbsEnv
</span><a href="ZM.Parser.Env.html#parseADTsWith"><span class="hs-identifier hs-var hs-var">parseADTsWith</span></a></span></span><span> </span><span id="local-6989586621679167859"><span class="annot"><span class="annottext">AbsEnv
</span><a href="#local-6989586621679167859"><span class="hs-identifier hs-var">absEnv</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-285"></span><span>  </span><span class="annot"><span class="annottext">(AtError -&gt; Either [AtError] AbsEnv)
-&gt; ([ADTParts] -&gt; Either [AtError] AbsEnv)
-&gt; Either AtError [ADTParts]
-&gt; Either [AtError] AbsEnv
forall a c b. (a -&gt; c) -&gt; (b -&gt; c) -&gt; Either a b -&gt; c
</span><span class="hs-identifier hs-var">either</span></span><span>
</span><span id="line-286"></span><span>    </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679167857"><span class="annot"><span class="annottext">AtError
</span><a href="#local-6989586621679167857"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[AtError] -&gt; Either [AtError] AbsEnv
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">AtError
</span><a href="#local-6989586621679167857"><span class="hs-identifier hs-var">e</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-287"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[ADTParts]
-&gt; Either
     [AtError] (Map (At (TypeName Identifier)) (ADT AtId AtId TRef))
</span><a href="ZM.Parser.Env.html#makeADTs"><span class="hs-identifier hs-var">makeADTs</span></a></span><span> </span><span class="annot"><span class="annottext">([ADTParts]
 -&gt; Either
      [AtError] (Map (At (TypeName Identifier)) (ADT AtId AtId TRef)))
-&gt; (Map (At (TypeName Identifier)) (ADT AtId AtId TRef)
    -&gt; Either [AtError] AbsEnv)
-&gt; [ADTParts]
-&gt; Either [AtError] AbsEnv
forall (m :: * -&gt; *) a b c.
Monad m =&gt;
(a -&gt; m b) -&gt; (b -&gt; m c) -&gt; a -&gt; m c
</span><span class="hs-operator hs-var">&gt;=&gt;</span></span><span> </span><span class="annot"><span class="annottext">AbsEnv
-&gt; Map (At (TypeName Identifier)) (ADT AtId AtId TRef)
-&gt; Either
     [AtError] (Map (At (TypeName Identifier)) (ADT AtId AtId TRef))
forall a name consName ref name2.
KeyOf (At (TypeName Identifier)) (a, ADT name consName ref) =&gt;
Map a (ADT name consName ref)
-&gt; Map
     (At (TypeName Identifier)) (ADT (Label Range name) name2 TRef)
-&gt; Either
     [AtError]
     (Map
        (At (TypeName Identifier)) (ADT (Label Range name) name2 TRef))
</span><a href="#local-6989586621679167854"><span class="hs-identifier hs-var">kindCheckWith</span></a></span><span> </span><span class="annot"><span class="annottext">AbsEnv
</span><a href="#local-6989586621679167859"><span class="hs-identifier hs-var">absEnv</span></a></span><span> </span><span class="annot"><span class="annottext">(Map (At (TypeName Identifier)) (ADT AtId AtId TRef)
 -&gt; Either
      [AtError] (Map (At (TypeName Identifier)) (ADT AtId AtId TRef)))
-&gt; (Map (At (TypeName Identifier)) (ADT AtId AtId TRef)
    -&gt; Either [AtError] AbsEnv)
-&gt; Map (At (TypeName Identifier)) (ADT AtId AtId TRef)
-&gt; Either [AtError] AbsEnv
forall (m :: * -&gt; *) a b c.
Monad m =&gt;
(a -&gt; m b) -&gt; (b -&gt; m c) -&gt; a -&gt; m c
</span><span class="hs-operator hs-var">&gt;=&gt;</span></span><span> </span><span class="annot"><span class="annottext">AbsEnv
-&gt; Map (At (TypeName Identifier)) (ADT AtId AtId TRef)
-&gt; Either [AtError] AbsEnv
forall n t t1.
Convertible n Identifier =&gt;
AbsEnv
-&gt; Map
     (At (TypeName Identifier))
     (ADT
        n n (TypeRef2 (Label (t, Word8) t1) (At (TypeName Identifier))))
-&gt; Either [AtError] AbsEnv
</span><a href="ZM.Parser.Env.html#toAbsEnvWith"><span class="hs-identifier hs-var">toAbsEnvWith</span></a></span><span> </span><span class="annot"><span class="annottext">AbsEnv
</span><a href="#local-6989586621679167859"><span class="hs-identifier hs-var">absEnv</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Either AtError [ADTParts] -&gt; Either [AtError] AbsEnv)
-&gt; (String -&gt; Either AtError [ADTParts])
-&gt; String
-&gt; Either [AtError] AbsEnv
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span>
</span><span id="line-288"></span><span>  </span><span class="annot"><span class="annottext">Parser [ADTParts] -&gt; String -&gt; Either AtError [ADTParts]
forall a. Parser a -&gt; String -&gt; Either AtError a
</span><a href="ZM.Parser.Util.html#parseDoc"><span class="hs-identifier hs-var">parseDoc</span></a></span><span> </span><span class="annot"><span class="annottext">Parser [ADTParts]
</span><a href="ZM.Parser.ADT.html#adts"><span class="hs-identifier hs-var">adts</span></a></span><span> </span><span class="hs-comment">--makeEnv &gt;=&gt; toAbsEnvWith absEnv</span><span>
</span><span id="line-289"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-290"></span><span>    </span><span id="local-6989586621679167854"><span class="annot"><span class="annottext">kindCheckWith :: Map a (ADT name consName ref)
-&gt; Map
     (At (TypeName Identifier)) (ADT (Label Range name) name2 TRef)
-&gt; Either
     [AtError]
     (Map
        (At (TypeName Identifier)) (ADT (Label Range name) name2 TRef))
</span><a href="#local-6989586621679167854"><span class="hs-identifier hs-var hs-var">kindCheckWith</span></a></span></span><span> </span><span id="local-6989586621679167850"><span class="annot"><span class="annottext">Map a (ADT name consName ref)
</span><a href="#local-6989586621679167850"><span class="hs-identifier hs-var">absEnv</span></a></span></span><span> </span><span id="local-6989586621679167849"><span class="annot"><span class="annottext">Map (At (TypeName Identifier)) (ADT (Label Range name) name2 TRef)
</span><a href="#local-6989586621679167849"><span class="hs-identifier hs-var">relEnv</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-291"></span><span>      </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">(ZMError
   (Either
      (Label (Range, Word8) Identifier) (At (TypeName Identifier)))
 -&gt; [AtError])
-&gt; [ZMError
      (Either
         (Label (Range, Word8) Identifier) (At (TypeName Identifier)))]
-&gt; [AtError]
forall (t :: * -&gt; *) a b. Foldable t =&gt; (a -&gt; [b]) -&gt; t a -&gt; [b]
</span><span class="hs-identifier hs-var">concatMap</span></span><span> </span><span class="annot"><span class="annottext">ZMError
  (Either
     (Label (Range, Word8) Identifier) (At (TypeName Identifier)))
-&gt; [AtError]
</span><a href="#local-6989586621679167847"><span class="hs-identifier hs-var">atk</span></a></span><span> </span><span class="annot"><span class="annottext">([ZMError
    (Either
       (Label (Range, Word8) Identifier) (At (TypeName Identifier)))]
 -&gt; [AtError])
-&gt; (Map
      (At (TypeName Identifier)) (ADT (Label Range name) name2 TRef)
    -&gt; [ZMError
          (Either
             (Label (Range, Word8) Identifier) (At (TypeName Identifier)))])
-&gt; Map
     (At (TypeName Identifier)) (ADT (Label Range name) name2 TRef)
-&gt; [AtError]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Map (At (TypeName Identifier)) (ADT (Label Range name) name2 TRef)
-&gt; [ZMError
      (Either
         (Label (Range, Word8) Identifier) (At (TypeName Identifier)))]
forall k name1 name2 a.
Ord k =&gt;
Map k (ADT name1 name2 (TypeRef2 a k)) -&gt; [ZMError (Either a k)]
</span><a href="ZM.Abs.html#kindErrors"><span class="hs-identifier hs-var">kindErrors</span></a></span><span> </span><span class="annot"><span class="annottext">(Map (At (TypeName Identifier)) (ADT (Label Range name) name2 TRef)
 -&gt; [AtError])
-&gt; Map
     (At (TypeName Identifier)) (ADT (Label Range name) name2 TRef)
-&gt; [AtError]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Map a (ADT name consName ref)
-&gt; Map
     (At (TypeName Identifier)) (ADT (Label Range name) name2 TRef)
-&gt; Map
     (At (TypeName Identifier)) (ADT (Label Range name) name2 TRef)
forall k a name consName ref consName ref.
(Ord k, KeyOf k (a, ADT name consName ref)) =&gt;
Map a (ADT name consName ref)
-&gt; Map k (ADT (Label Range name) consName ref)
-&gt; Map k (ADT (Label Range name) consName ref)
</span><a href="#local-6989586621679167845"><span class="hs-identifier hs-var">addAbsEnv</span></a></span><span> </span><span class="annot"><span class="annottext">Map a (ADT name consName ref)
</span><a href="#local-6989586621679167850"><span class="hs-identifier hs-var">absEnv</span></a></span><span> </span><span class="annot"><span class="annottext">Map (At (TypeName Identifier)) (ADT (Label Range name) name2 TRef)
</span><a href="#local-6989586621679167849"><span class="hs-identifier hs-var">relEnv</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-292"></span><span>        </span><span class="hs-special">[</span><span class="hs-special">]</span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Map (At (TypeName Identifier)) (ADT (Label Range name) name2 TRef)
-&gt; Either
     [AtError]
     (Map
        (At (TypeName Identifier)) (ADT (Label Range name) name2 TRef))
forall a b. b -&gt; Either a b
</span><span class="hs-identifier hs-var">Right</span></span><span> </span><span class="annot"><span class="annottext">Map (At (TypeName Identifier)) (ADT (Label Range name) name2 TRef)
</span><a href="#local-6989586621679167849"><span class="hs-identifier hs-var">relEnv</span></a></span><span>
</span><span id="line-293"></span><span>        </span><span id="local-6989586621679167844"><span class="annot"><span class="annottext">[AtError]
</span><a href="#local-6989586621679167844"><span class="hs-identifier hs-var">errs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[AtError]
-&gt; Either
     [AtError]
     (Map
        (At (TypeName Identifier)) (ADT (Label Range name) name2 TRef))
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="annot"><span class="annottext">[AtError]
</span><a href="#local-6989586621679167844"><span class="hs-identifier hs-var">errs</span></a></span><span>
</span><span id="line-294"></span><span>    </span><span class="annot"><a href="#local-6989586621679167847"><span class="hs-identifier hs-type">atk</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-295"></span><span>         </span><span class="annot"><a href="ZM.Types.html#ZMError"><span class="hs-identifier hs-type">ZMError</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Parser.Types.html#Label"><span class="hs-identifier hs-type">Label</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Parser.Types.html#Range"><span class="hs-identifier hs-type">Range</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word8</span></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="ZM.Types.html#Identifier"><span class="hs-identifier hs-type">Identifier</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Parser.Types.html#At"><span class="hs-identifier hs-type">At</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Parser.Types.html#TypeName"><span class="hs-identifier hs-type">TypeName</span></a></span><span> </span><span class="annot"><a href="ZM.Types.html#Identifier"><span class="hs-identifier hs-type">Identifier</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-296"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="ZM.Parser.Types.html#At"><span class="hs-identifier hs-type">At</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span>
</span><span id="line-297"></span><span>    </span><span id="local-6989586621679167847"><span class="annot"><span class="annottext">atk :: ZMError
  (Either
     (Label (Range, Word8) Identifier) (At (TypeName Identifier)))
-&gt; [AtError]
</span><a href="#local-6989586621679167847"><span class="hs-identifier hs-var hs-var">atk</span></a></span></span><span> </span><span id="local-6989586621679167843"><span class="annot"><span class="annottext">ZMError
  (Either
     (Label (Range, Word8) Identifier) (At (TypeName Identifier)))
</span><a href="#local-6989586621679167843"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-298"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679167842"><span class="annot"><span class="annottext">s :: String
</span><a href="#local-6989586621679167842"><span class="hs-identifier hs-var hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ZMError Doc -&gt; String
forall a. Pretty a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">prettyShow</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Label (Range, Word8) Identifier -&gt; Doc)
-&gt; (At (TypeName Identifier) -&gt; Doc)
-&gt; Either
     (Label (Range, Word8) Identifier) (At (TypeName Identifier))
-&gt; Doc
forall a c b. (a -&gt; c) -&gt; (b -&gt; c) -&gt; Either a b -&gt; c
</span><span class="hs-identifier hs-var">either</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Identifier -&gt; Doc
forall a. Pretty a =&gt; a -&gt; Doc
</span><span class="hs-identifier hs-var">pPrint</span></span><span> </span><span class="annot"><span class="annottext">(Identifier -&gt; Doc)
-&gt; (Label (Range, Word8) Identifier -&gt; Identifier)
-&gt; Label (Range, Word8) Identifier
-&gt; Doc
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Label (Range, Word8) Identifier -&gt; Identifier
forall l a. Label l a -&gt; a
</span><a href="ZM.Parser.Types.html#object"><span class="hs-identifier hs-var hs-var">object</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TypeName Identifier -&gt; Doc
forall a. Pretty a =&gt; a -&gt; Doc
</span><span class="hs-identifier hs-var">pPrint</span></span><span> </span><span class="annot"><span class="annottext">(TypeName Identifier -&gt; Doc)
-&gt; (At (TypeName Identifier) -&gt; TypeName Identifier)
-&gt; At (TypeName Identifier)
-&gt; Doc
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">At (TypeName Identifier) -&gt; TypeName Identifier
forall l a. Label l a -&gt; a
</span><a href="ZM.Parser.Types.html#object"><span class="hs-identifier hs-var hs-var">object</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Either
   (Label (Range, Word8) Identifier) (At (TypeName Identifier))
 -&gt; Doc)
-&gt; ZMError
     (Either
        (Label (Range, Word8) Identifier) (At (TypeName Identifier)))
-&gt; ZMError Doc
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ZMError
  (Either
     (Label (Range, Word8) Identifier) (At (TypeName Identifier)))
</span><a href="#local-6989586621679167843"><span class="hs-identifier hs-var">e</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-299"></span><span>       </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">(Either
   (Label (Range, Word8) Identifier) (At (TypeName Identifier))
 -&gt; AtError)
-&gt; [Either
      (Label (Range, Word8) Identifier) (At (TypeName Identifier))]
-&gt; [AtError]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Label (Range, Word8) Identifier -&gt; AtError)
-&gt; (At (TypeName Identifier) -&gt; AtError)
-&gt; Either
     (Label (Range, Word8) Identifier) (At (TypeName Identifier))
-&gt; AtError
forall a c b. (a -&gt; c) -&gt; (b -&gt; c) -&gt; Either a b -&gt; c
</span><span class="hs-identifier hs-var">either</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679167837"><span class="annot"><span class="annottext">Label (Range, Word8) Identifier
</span><a href="#local-6989586621679167837"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Range -&gt; String -&gt; AtError
forall l a. l -&gt; a -&gt; Label l a
</span><a href="ZM.Parser.Types.html#Label"><span class="hs-identifier hs-var">Label</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Range, Word8) -&gt; Range
forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span> </span><span class="annot"><span class="annottext">((Range, Word8) -&gt; Range) -&gt; (Range, Word8) -&gt; Range
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Label (Range, Word8) Identifier -&gt; (Range, Word8)
forall l a. Label l a -&gt; l
</span><a href="ZM.Parser.Types.html#label"><span class="hs-keyword hs-var hs-var">label</span></a></span><span> </span><span class="annot"><span class="annottext">Label (Range, Word8) Identifier
</span><a href="#local-6989586621679167837"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679167842"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679167834"><span class="annot"><span class="annottext">At (TypeName Identifier)
</span><a href="#local-6989586621679167834"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Range -&gt; String -&gt; AtError
forall l a. l -&gt; a -&gt; Label l a
</span><a href="ZM.Parser.Types.html#Label"><span class="hs-identifier hs-var">Label</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">At (TypeName Identifier) -&gt; Range
forall l a. Label l a -&gt; l
</span><a href="ZM.Parser.Types.html#label"><span class="hs-keyword hs-var hs-var">label</span></a></span><span> </span><span class="annot"><span class="annottext">At (TypeName Identifier)
</span><a href="#local-6989586621679167834"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679167842"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">([Either
    (Label (Range, Word8) Identifier) (At (TypeName Identifier))]
 -&gt; [AtError])
-&gt; [Either
      (Label (Range, Word8) Identifier) (At (TypeName Identifier))]
-&gt; [AtError]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-300"></span><span>          </span><span class="annot"><span class="annottext">ZMError
  (Either
     (Label (Range, Word8) Identifier) (At (TypeName Identifier)))
-&gt; [Either
      (Label (Range, Word8) Identifier) (At (TypeName Identifier))]
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; [a]
</span><span class="hs-identifier hs-var">toList</span></span><span> </span><span class="annot"><span class="annottext">ZMError
  (Either
     (Label (Range, Word8) Identifier) (At (TypeName Identifier)))
</span><a href="#local-6989586621679167843"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-301"></span><span>    </span><span id="local-6989586621679167845"><span class="annot"><span class="annottext">addAbsEnv :: Map a (ADT name consName ref)
-&gt; Map k (ADT (Label Range name) consName ref)
-&gt; Map k (ADT (Label Range name) consName ref)
</span><a href="#local-6989586621679167845"><span class="hs-identifier hs-var hs-var">addAbsEnv</span></a></span></span><span> </span><span id="local-6989586621679167832"><span class="annot"><span class="annottext">Map a (ADT name consName ref)
</span><a href="#local-6989586621679167832"><span class="hs-identifier hs-var">absEnv</span></a></span></span><span> </span><span id="local-6989586621679167831"><span class="annot"><span class="annottext">Map k (ADT (Label Range name) consName ref)
</span><a href="#local-6989586621679167831"><span class="hs-identifier hs-var">relEnv</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-302"></span><span>      </span><span class="annot"><span class="annottext">Map k (ADT (Label Range name) consName ref)
</span><a href="#local-6989586621679167831"><span class="hs-identifier hs-var">relEnv</span></a></span><span> </span><span class="annot"><span class="annottext">Map k (ADT (Label Range name) consName ref)
-&gt; Map k (ADT (Label Range name) consName ref)
-&gt; Map k (ADT (Label Range name) consName ref)
forall k a. Ord k =&gt; Map k a -&gt; Map k a -&gt; Map k a
</span><span class="hs-operator hs-var">`M.union`</span></span><span>
</span><span id="line-303"></span><span>      </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[(k, ADT (Label Range name) consName ref)]
-&gt; Map k (ADT (Label Range name) consName ref)
forall k a. Ord k =&gt; [(k, a)] -&gt; Map k a
</span><span class="hs-identifier hs-var">M.fromList</span></span><span> </span><span class="annot"><span class="annottext">([(k, ADT (Label Range name) consName ref)]
 -&gt; Map k (ADT (Label Range name) consName ref))
-&gt; (Map a (ADT name consName ref)
    -&gt; [(k, ADT (Label Range name) consName ref)])
-&gt; Map a (ADT name consName ref)
-&gt; Map k (ADT (Label Range name) consName ref)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span>
</span><span id="line-304"></span><span>       </span><span class="annot"><span class="annottext">((a, ADT name consName ref)
 -&gt; (k, ADT (Label Range name) consName ref))
-&gt; [(a, ADT name consName ref)]
-&gt; [(k, ADT (Label Range name) consName ref)]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span>
</span><span id="line-305"></span><span>         </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679167828"><span class="annot"><span class="annottext">radt :: (a, ADT name consName ref)
</span><a href="#local-6989586621679167828"><span class="hs-identifier hs-var">radt</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679167827"><span class="annot"><span class="annottext">ADT name consName ref
</span><a href="#local-6989586621679167827"><span class="hs-identifier hs-var">adt</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-306"></span><span>            </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">(a, ADT name consName ref) -&gt; k
forall k a. KeyOf k a =&gt; a -&gt; k
</span><a href="ZM.Abs.html#keyOf"><span class="hs-identifier hs-var">keyOf</span></a></span><span> </span><span class="annot"><span class="annottext">(a, ADT name consName ref)
</span><a href="#local-6989586621679167828"><span class="hs-identifier hs-var">radt</span></a></span><span>
</span><span id="line-307"></span><span>            </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Label Range name
-&gt; Word8
-&gt; Maybe (ConTree consName ref)
-&gt; ADT (Label Range name) consName ref
forall name consName ref.
name
-&gt; Word8 -&gt; Maybe (ConTree consName ref) -&gt; ADT name consName ref
</span><span class="hs-identifier hs-var">ADT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">name -&gt; Label Range name
forall a. a -&gt; Label Range a
</span><a href="ZM.Parser.Env.html#at0"><span class="hs-identifier hs-var">at0</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ADT name consName ref -&gt; name
forall name consName ref. ADT name consName ref -&gt; name
</span><span class="hs-identifier hs-var hs-var">declName</span></span><span> </span><span class="annot"><span class="annottext">ADT name consName ref
</span><a href="#local-6989586621679167827"><span class="hs-identifier hs-var">adt</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ADT name consName ref -&gt; Word8
forall name consName ref. ADT name consName ref -&gt; Word8
</span><span class="hs-identifier hs-var hs-var">declNumParameters</span></span><span> </span><span class="annot"><span class="annottext">ADT name consName ref
</span><a href="#local-6989586621679167827"><span class="hs-identifier hs-var">adt</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe (ConTree consName ref)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">([(a, ADT name consName ref)]
 -&gt; [(k, ADT (Label Range name) consName ref)])
-&gt; (Map a (ADT name consName ref) -&gt; [(a, ADT name consName ref)])
-&gt; Map a (ADT name consName ref)
-&gt; [(k, ADT (Label Range name) consName ref)]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span>
</span><span id="line-308"></span><span>       </span><span class="annot"><span class="annottext">Map a (ADT name consName ref) -&gt; [(a, ADT name consName ref)]
forall k a. Map k a -&gt; [(k, a)]
</span><span class="hs-identifier hs-var">M.toList</span></span><span> </span><span class="annot"><span class="annottext">(Map a (ADT name consName ref)
 -&gt; Map k (ADT (Label Range name) consName ref))
-&gt; Map a (ADT name consName ref)
-&gt; Map k (ADT (Label Range name) consName ref)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-309"></span><span>       </span><span class="annot"><span class="annottext">Map a (ADT name consName ref)
</span><a href="#local-6989586621679167832"><span class="hs-identifier hs-var">absEnv</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-310"></span><span>
</span><span id="line-311"></span><span class="hs-comment">-- makeEnv ::</span><span>
</span><span id="line-312"></span><span class="hs-comment">--      [ADTParts]</span><span>
</span><span id="line-313"></span><span class="hs-comment">--   -&gt; Either [AtError] (M.Map (At (TypeName Identifier)) (ADT AtId AtId (TypeRef2 (Label ( Range</span><span>
</span><span id="line-314"></span><span class="hs-comment">--                                                                                         , Word8) Identifier) (At (TypeName Identifier)))))</span><span>
</span><span id="line-315"></span><span class="hs-comment">-- makeEnv = makeADTs</span><span>
</span><span id="line-316"></span><span id="local-6989586621679167981"><span id="local-6989586621679167982"><span id="local-6989586621679167984"><span class="annot"><a href="ZM.Parser.Env.html#toAbsEnvWith"><span class="hs-identifier hs-type">toAbsEnvWith</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-317"></span><span>     </span><span class="annot"><span class="hs-identifier hs-type">Convertible</span></span><span> </span><span class="annot"><a href="#local-6989586621679167984"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><a href="ZM.Types.html#Identifier"><span class="hs-identifier hs-type">Identifier</span></a></span><span>
</span><span id="line-318"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="ZM.Types.html#AbsEnv"><span class="hs-identifier hs-type">AbsEnv</span></a></span><span>
</span><span id="line-319"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">M.Map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Parser.Types.html#At"><span class="hs-identifier hs-type">At</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Parser.Types.html#TypeName"><span class="hs-identifier hs-type">TypeName</span></a></span><span> </span><span class="annot"><a href="ZM.Types.html#Identifier"><span class="hs-identifier hs-type">Identifier</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ADT</span></span><span> </span><span class="annot"><a href="#local-6989586621679167984"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679167984"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Abs.html#TypeRef2"><span class="hs-identifier hs-type">TypeRef2</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Parser.Types.html#Label"><span class="hs-identifier hs-type">Label</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679167982"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word8</span></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679167981"><span class="hs-identifier hs-type">t1</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Parser.Types.html#At"><span class="hs-identifier hs-type">At</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Parser.Types.html#TypeName"><span class="hs-identifier hs-type">TypeName</span></a></span><span> </span><span class="annot"><a href="ZM.Types.html#Identifier"><span class="hs-identifier hs-type">Identifier</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-320"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="ZM.Parser.Types.html#At"><span class="hs-identifier hs-type">At</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="ZM.Types.html#AbsEnv"><span class="hs-identifier hs-type">AbsEnv</span></a></span></span></span></span><span>
</span><span id="line-321"></span><span id="toAbsEnvWith"><span class="annot"><span class="annottext">toAbsEnvWith :: AbsEnv
-&gt; Map
     (At (TypeName Identifier))
     (ADT
        n n (TypeRef2 (Label (t, Word8) t1) (At (TypeName Identifier))))
-&gt; Either [AtError] AbsEnv
</span><a href="ZM.Parser.Env.html#toAbsEnvWith"><span class="hs-identifier hs-var hs-var">toAbsEnvWith</span></a></span></span><span> </span><span id="local-6989586621679167820"><span class="annot"><span class="annottext">AbsEnv
</span><a href="#local-6989586621679167820"><span class="hs-identifier hs-var">absEnv</span></a></span></span><span>
</span><span id="line-322"></span><span>  </span><span class="hs-comment">--let extEnv = relEnv `M.union` (M.fromList . map (\radt -&gt; (keyOf radt,ADT (Label (Range 0 0 0) (TypeName &quot;&quot; Nothing)) 0 Nothing)) .  M.toList $ absEnv)</span><span>
</span><span id="line-323"></span><span>  </span><span class="hs-comment">-- in first (concatMap ate) . relToAbsEnvWith absEnv . ((asRef &lt;$&gt;) &lt;$&gt;) $ relEnv</span><span>
</span><span id="line-324"></span><span>  </span><span class="hs-comment">--in first (concatMap ate) . relToAbsEnv . ((asRef &lt;$&gt;) &lt;$&gt;) $ extEnv</span><span>
</span><span id="line-325"></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([ZMError (At (TypeName Identifier))] -&gt; [AtError])
-&gt; Either [ZMError (At (TypeName Identifier))] AbsEnv
-&gt; Either [AtError] AbsEnv
forall (p :: * -&gt; * -&gt; *) a b c.
Bifunctor p =&gt;
(a -&gt; b) -&gt; p a c -&gt; p b c
</span><span class="hs-identifier hs-var">first</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(ZMError (At (TypeName Identifier)) -&gt; [AtError])
-&gt; [ZMError (At (TypeName Identifier))] -&gt; [AtError]
forall (t :: * -&gt; *) a b. Foldable t =&gt; (a -&gt; [b]) -&gt; t a -&gt; [b]
</span><span class="hs-identifier hs-var">concatMap</span></span><span> </span><span class="annot"><span class="annottext">ZMError (At (TypeName Identifier)) -&gt; [AtError]
</span><a href="#local-6989586621679167818"><span class="hs-identifier hs-var">ate</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Either [ZMError (At (TypeName Identifier))] AbsEnv
 -&gt; Either [AtError] AbsEnv)
-&gt; (Map
      (At (TypeName Identifier))
      (ADT
         n n (TypeRef2 (Label (t, Word8) t1) (At (TypeName Identifier))))
    -&gt; Either [ZMError (At (TypeName Identifier))] AbsEnv)
-&gt; Map
     (At (TypeName Identifier))
     (ADT
        n n (TypeRef2 (Label (t, Word8) t1) (At (TypeName Identifier))))
-&gt; Either [AtError] AbsEnv
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">AbsEnv
-&gt; RelTypeEnv n (At (TypeName Identifier))
-&gt; Either [ZMError (At (TypeName Identifier))] AbsEnv
forall r n.
(IsKey r, IsId n) =&gt;
AbsEnv -&gt; RelTypeEnv n r -&gt; Either [ZMError r] AbsEnv
</span><a href="ZM.Abs.html#relToAbsEnvWith"><span class="hs-identifier hs-var">relToAbsEnvWith</span></a></span><span> </span><span class="annot"><span class="annottext">AbsEnv
</span><a href="#local-6989586621679167820"><span class="hs-identifier hs-var">absEnv</span></a></span><span> </span><span class="annot"><span class="annottext">(RelTypeEnv n (At (TypeName Identifier))
 -&gt; Either [ZMError (At (TypeName Identifier))] AbsEnv)
-&gt; (Map
      (At (TypeName Identifier))
      (ADT
         n n (TypeRef2 (Label (t, Word8) t1) (At (TypeName Identifier))))
    -&gt; RelTypeEnv n (At (TypeName Identifier)))
-&gt; Map
     (At (TypeName Identifier))
     (ADT
        n n (TypeRef2 (Label (t, Word8) t1) (At (TypeName Identifier))))
-&gt; Either [ZMError (At (TypeName Identifier))] AbsEnv
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">TypeRef2 (Label (t, Word8) t1) (At (TypeName Identifier))
-&gt; TypeRef (At (TypeName Identifier))
forall a a1 name.
TypeRef2 (Label (a, Word8) a1) name -&gt; TypeRef name
</span><a href="ZM.Parser.Env.html#asRef"><span class="hs-identifier hs-var">asRef</span></a></span><span> </span><span class="annot"><span class="annottext">(TypeRef2 (Label (t, Word8) t1) (At (TypeName Identifier))
 -&gt; TypeRef (At (TypeName Identifier)))
-&gt; ADT
     n n (TypeRef2 (Label (t, Word8) t1) (At (TypeName Identifier)))
-&gt; ADT n n (TypeRef (At (TypeName Identifier)))
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(ADT
   n n (TypeRef2 (Label (t, Word8) t1) (At (TypeName Identifier)))
 -&gt; ADT n n (TypeRef (At (TypeName Identifier))))
-&gt; Map
     (At (TypeName Identifier))
     (ADT
        n n (TypeRef2 (Label (t, Word8) t1) (At (TypeName Identifier))))
-&gt; RelTypeEnv n (At (TypeName Identifier))
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span class="hs-special">)</span><span>
</span><span id="line-326"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-327"></span><span>    </span><span class="annot"><a href="#local-6989586621679167818"><span class="hs-identifier hs-type">ate</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="ZM.Types.html#ZMError"><span class="hs-identifier hs-type">ZMError</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Parser.Types.html#At"><span class="hs-identifier hs-type">At</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Parser.Types.html#TypeName"><span class="hs-identifier hs-type">TypeName</span></a></span><span> </span><span class="annot"><a href="ZM.Types.html#Identifier"><span class="hs-identifier hs-type">Identifier</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="ZM.Parser.Types.html#At"><span class="hs-identifier hs-type">At</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span>
</span><span id="line-328"></span><span>    </span><span id="local-6989586621679167818"><span class="annot"><span class="annottext">ate :: ZMError (At (TypeName Identifier)) -&gt; [AtError]
</span><a href="#local-6989586621679167818"><span class="hs-identifier hs-var hs-var">ate</span></a></span></span><span> </span><span id="local-6989586621679167815"><span class="annot"><span class="annottext">ZMError (At (TypeName Identifier))
</span><a href="#local-6989586621679167815"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-329"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679167814"><span class="annot"><span class="annottext">s :: String
</span><a href="#local-6989586621679167814"><span class="hs-identifier hs-var hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ZMError (TypeName Identifier) -&gt; String
forall a. Pretty a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">prettyShow</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">At (TypeName Identifier) -&gt; TypeName Identifier
forall l a. Label l a -&gt; a
</span><a href="ZM.Parser.Types.html#object"><span class="hs-identifier hs-var hs-var">object</span></a></span><span> </span><span class="annot"><span class="annottext">(At (TypeName Identifier) -&gt; TypeName Identifier)
-&gt; ZMError (At (TypeName Identifier))
-&gt; ZMError (TypeName Identifier)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ZMError (At (TypeName Identifier))
</span><a href="#local-6989586621679167815"><span class="hs-identifier hs-var">e</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-330"></span><span>       </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">(At (TypeName Identifier) -&gt; AtError)
-&gt; [At (TypeName Identifier)] -&gt; [AtError]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679167813"><span class="annot"><span class="annottext">At (TypeName Identifier)
</span><a href="#local-6989586621679167813"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Range -&gt; String -&gt; AtError
forall l a. l -&gt; a -&gt; Label l a
</span><a href="ZM.Parser.Types.html#Label"><span class="hs-identifier hs-var">Label</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">At (TypeName Identifier) -&gt; Range
forall l a. Label l a -&gt; l
</span><a href="ZM.Parser.Types.html#label"><span class="hs-keyword hs-var hs-var">label</span></a></span><span> </span><span class="annot"><span class="annottext">At (TypeName Identifier)
</span><a href="#local-6989586621679167813"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679167814"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">([At (TypeName Identifier)] -&gt; [AtError])
-&gt; [At (TypeName Identifier)] -&gt; [AtError]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">ZMError (At (TypeName Identifier)) -&gt; [At (TypeName Identifier)]
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; [a]
</span><span class="hs-identifier hs-var">toList</span></span><span> </span><span class="annot"><span class="annottext">ZMError (At (TypeName Identifier))
</span><a href="#local-6989586621679167815"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-331"></span><span>
</span><span id="line-332"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="ZM.Abs.html#KeyOf"><span class="hs-identifier hs-type">KeyOf</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Parser.Types.html#At"><span class="hs-identifier hs-type">At</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Parser.Types.html#TypeName"><span class="hs-identifier hs-type">TypeName</span></a></span><span> </span><span class="annot"><a href="ZM.Types.html#Identifier"><span class="hs-identifier hs-type">Identifier</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Types.html#AbsRef"><span class="hs-identifier hs-type">AbsRef</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="ZM.Types.html#AbsADT"><span class="hs-identifier hs-type">AbsADT</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-333"></span><span>  </span><span id="local-6989586621679167810"><span class="annot"><span class="annottext">keyOf :: (AbsRef, AbsADT) -&gt; At (TypeName Identifier)
</span><a href="#local-6989586621679167810"><span class="hs-identifier hs-var hs-var hs-var hs-var">keyOf</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679167809"><span class="annot"><span class="annottext">AbsRef
</span><a href="#local-6989586621679167809"><span class="hs-identifier hs-var">ref</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679167808"><span class="annot"><span class="annottext">AbsADT
</span><a href="#local-6989586621679167808"><span class="hs-identifier hs-var">adt</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TypeName Identifier -&gt; At (TypeName Identifier)
forall a. a -&gt; Label Range a
</span><a href="ZM.Parser.Env.html#at0"><span class="hs-identifier hs-var">at0</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe Identifier -&gt; Maybe AbsRef -&gt; TypeName Identifier
forall a b. Maybe a -&gt; Maybe b -&gt; These a b
</span><a href="ZM.Parser.Types.html#asTypeName"><span class="hs-identifier hs-var">asTypeName</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Identifier -&gt; Maybe Identifier
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">(Identifier -&gt; Maybe Identifier) -&gt; Identifier -&gt; Maybe Identifier
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">AbsADT -&gt; Identifier
forall name consName ref. ADT name consName ref -&gt; name
</span><span class="hs-identifier hs-var hs-var">declName</span></span><span> </span><span class="annot"><span class="annottext">AbsADT
</span><a href="#local-6989586621679167808"><span class="hs-identifier hs-var">adt</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">AbsRef -&gt; Maybe AbsRef
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">AbsRef
</span><a href="#local-6989586621679167809"><span class="hs-identifier hs-var">ref</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-334"></span><span>
</span><span id="line-335"></span><span id="local-6989586621679167931"><span class="annot"><a href="ZM.Parser.Env.html#at0"><span class="hs-identifier hs-type">at0</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679167931"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="ZM.Parser.Types.html#Label"><span class="hs-identifier hs-type">Label</span></a></span><span> </span><span class="annot"><a href="ZM.Parser.Types.html#Range"><span class="hs-identifier hs-type">Range</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679167931"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-336"></span><span id="at0"><span class="annot"><span class="annottext">at0 :: a -&gt; Label Range a
</span><a href="ZM.Parser.Env.html#at0"><span class="hs-identifier hs-var hs-var">at0</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Range -&gt; a -&gt; Label Range a
forall l a. l -&gt; a -&gt; Label l a
</span><a href="ZM.Parser.Types.html#Label"><span class="hs-identifier hs-var">Label</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Word32 -&gt; Word32 -&gt; Word32 -&gt; Range
</span><a href="ZM.Parser.Types.html#Range"><span class="hs-identifier hs-var">Range</span></a></span><span> </span><span class="annot"><span class="annottext">Word32
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">Word32
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">Word32
</span><span class="hs-number">0</span></span><span class="hs-special">)</span><span>
</span><span id="line-337"></span><span>
</span><span id="line-338"></span><span class="hs-comment">-- FIX: to be moved in main model</span><span>
</span><span id="line-339"></span><span class="hs-keyword">type</span><span> </span><span id="TRef"><span class="annot"><a href="ZM.Parser.Env.html#TRef"><span class="hs-identifier hs-var">TRef</span></a></span></span><span>
</span><span id="line-340"></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="ZM.Abs.html#TypeRef2"><span class="hs-identifier hs-type">TypeRef2</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Parser.Types.html#Label"><span class="hs-identifier hs-type">Label</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Parser.Types.html#Range"><span class="hs-identifier hs-type">Range</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word8</span></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="ZM.Types.html#Identifier"><span class="hs-identifier hs-type">Identifier</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Parser.Types.html#At"><span class="hs-identifier hs-type">At</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Parser.Types.html#TypeName"><span class="hs-identifier hs-type">TypeName</span></a></span><span> </span><span class="annot"><a href="ZM.Types.html#Identifier"><span class="hs-identifier hs-type">Identifier</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-341"></span><span>
</span><span id="line-342"></span><span class="annot"><a href="ZM.Parser.Env.html#makeADTs"><span class="hs-identifier hs-type">makeADTs</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-343"></span><span>     </span><span class="hs-special">[</span><span class="annot"><a href="ZM.Parser.Types.html#ADTParts"><span class="hs-identifier hs-type">ADTParts</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-344"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="ZM.Parser.Types.html#AtError"><span class="hs-identifier hs-type">AtError</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">M.Map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Parser.Types.html#At"><span class="hs-identifier hs-type">At</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Parser.Types.html#TypeName"><span class="hs-identifier hs-type">TypeName</span></a></span><span> </span><span class="annot"><a href="ZM.Types.html#Identifier"><span class="hs-identifier hs-type">Identifier</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ADT</span></span><span> </span><span class="annot"><a href="ZM.Parser.Types.html#AtId"><span class="hs-identifier hs-type">AtId</span></a></span><span> </span><span class="annot"><a href="ZM.Parser.Types.html#AtId"><span class="hs-identifier hs-type">AtId</span></a></span><span> </span><span class="annot"><a href="ZM.Parser.Env.html#TRef"><span class="hs-identifier hs-type">TRef</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-345"></span><span id="makeADTs"><span class="annot"><span class="annottext">makeADTs :: [ADTParts]
-&gt; Either
     [AtError] (Map (At (TypeName Identifier)) (ADT AtId AtId TRef))
</span><a href="ZM.Parser.Env.html#makeADTs"><span class="hs-identifier hs-var hs-var">makeADTs</span></a></span></span><span> </span><span id="local-6989586621679167805"><span class="annot"><span class="annottext">[ADTParts]
</span><a href="#local-6989586621679167805"><span class="hs-identifier hs-var">adts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-346"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679167804"><span class="annot"><span class="annottext">eadts :: [Either [AtError] (At (TypeName Identifier), ADT AtId AtId TRef)]
</span><a href="#local-6989586621679167804"><span class="hs-identifier hs-var hs-var">eadts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(ADTParts
 -&gt; Either [AtError] (At (TypeName Identifier), ADT AtId AtId TRef))
-&gt; [ADTParts]
-&gt; [Either
      [AtError] (At (TypeName Identifier), ADT AtId AtId TRef)]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">ADTParts
-&gt; Either [AtError] (At (TypeName Identifier), ADT AtId AtId TRef)
</span><a href="ZM.Parser.Env.html#makeADT"><span class="hs-identifier hs-var">makeADT</span></a></span><span> </span><span class="annot"><span class="annottext">[ADTParts]
</span><a href="#local-6989586621679167805"><span class="hs-identifier hs-var">adts</span></a></span><span>
</span><span id="line-347"></span><span>      </span><span id="local-6989586621679167802"><span class="annot"><span class="annottext">errors :: [AtError]
</span><a href="#local-6989586621679167802"><span class="hs-identifier hs-var hs-var">errors</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[[AtError]] -&gt; [AtError]
forall (t :: * -&gt; *) a. Foldable t =&gt; t [a] -&gt; [a]
</span><span class="hs-identifier hs-var">concat</span></span><span> </span><span class="annot"><span class="annottext">([[AtError]] -&gt; [AtError]) -&gt; [[AtError]] -&gt; [AtError]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Either [AtError] (At (TypeName Identifier), ADT AtId AtId TRef)]
-&gt; [[AtError]]
forall a b. [Either a b] -&gt; [a]
</span><span class="hs-identifier hs-var">lefts</span></span><span> </span><span class="annot"><span class="annottext">[Either [AtError] (At (TypeName Identifier), ADT AtId AtId TRef)]
</span><a href="#local-6989586621679167804"><span class="hs-identifier hs-var">eadts</span></a></span><span>
</span><span id="line-348"></span><span>   </span><span class="hs-keyword">in</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">[AtError] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">[AtError]
</span><a href="#local-6989586621679167802"><span class="hs-identifier hs-var">errors</span></a></span><span>
</span><span id="line-349"></span><span>        </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">Map (At (TypeName Identifier)) (ADT AtId AtId TRef)
-&gt; Either
     [AtError] (Map (At (TypeName Identifier)) (ADT AtId AtId TRef))
forall a b. b -&gt; Either a b
</span><span class="hs-identifier hs-var">Right</span></span><span> </span><span class="annot"><span class="annottext">(Map (At (TypeName Identifier)) (ADT AtId AtId TRef)
 -&gt; Either
      [AtError] (Map (At (TypeName Identifier)) (ADT AtId AtId TRef)))
-&gt; ([(At (TypeName Identifier), ADT AtId AtId TRef)]
    -&gt; Map (At (TypeName Identifier)) (ADT AtId AtId TRef))
-&gt; [(At (TypeName Identifier), ADT AtId AtId TRef)]
-&gt; Either
     [AtError] (Map (At (TypeName Identifier)) (ADT AtId AtId TRef))
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">[(At (TypeName Identifier), ADT AtId AtId TRef)]
-&gt; Map (At (TypeName Identifier)) (ADT AtId AtId TRef)
forall k a. Ord k =&gt; [(k, a)] -&gt; Map k a
</span><span class="hs-identifier hs-var">M.fromList</span></span><span> </span><span class="annot"><span class="annottext">([(At (TypeName Identifier), ADT AtId AtId TRef)]
 -&gt; Either
      [AtError] (Map (At (TypeName Identifier)) (ADT AtId AtId TRef)))
-&gt; [(At (TypeName Identifier), ADT AtId AtId TRef)]
-&gt; Either
     [AtError] (Map (At (TypeName Identifier)) (ADT AtId AtId TRef))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Either [AtError] (At (TypeName Identifier), ADT AtId AtId TRef)]
-&gt; [(At (TypeName Identifier), ADT AtId AtId TRef)]
forall a b. [Either a b] -&gt; [b]
</span><span class="hs-identifier hs-var">rights</span></span><span> </span><span class="annot"><span class="annottext">[Either [AtError] (At (TypeName Identifier), ADT AtId AtId TRef)]
</span><a href="#local-6989586621679167804"><span class="hs-identifier hs-var">eadts</span></a></span><span>
</span><span id="line-350"></span><span>        </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">[AtError]
-&gt; Either
     [AtError] (Map (At (TypeName Identifier)) (ADT AtId AtId TRef))
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="annot"><span class="annottext">[AtError]
</span><a href="#local-6989586621679167802"><span class="hs-identifier hs-var">errors</span></a></span><span>
</span><span id="line-351"></span><span>
</span><span id="line-352"></span><span class="annot"><a href="ZM.Parser.Env.html#makeADT"><span class="hs-identifier hs-type">makeADT</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-353"></span><span>     </span><span class="annot"><a href="ZM.Parser.Types.html#ADTParts"><span class="hs-identifier hs-type">ADTParts</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="ZM.Parser.Types.html#AtError"><span class="hs-identifier hs-type">AtError</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Parser.Types.html#At"><span class="hs-identifier hs-type">At</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Parser.Types.html#TypeName"><span class="hs-identifier hs-type">TypeName</span></a></span><span> </span><span class="annot"><a href="ZM.Types.html#Identifier"><span class="hs-identifier hs-type">Identifier</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">ADT</span></span><span> </span><span class="annot"><a href="ZM.Parser.Types.html#AtId"><span class="hs-identifier hs-type">AtId</span></a></span><span> </span><span class="annot"><a href="ZM.Parser.Types.html#AtId"><span class="hs-identifier hs-type">AtId</span></a></span><span> </span><span class="annot"><a href="ZM.Parser.Env.html#TRef"><span class="hs-identifier hs-type">TRef</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-354"></span><span id="makeADT"><span class="annot"><span class="annottext">makeADT :: ADTParts
-&gt; Either [AtError] (At (TypeName Identifier), ADT AtId AtId TRef)
</span><a href="ZM.Parser.Env.html#makeADT"><span class="hs-identifier hs-var hs-var">makeADT</span></a></span></span><span> </span><span id="local-6989586621679167797"><span class="annot"><span class="annottext">ADTParts
</span><a href="#local-6989586621679167797"><span class="hs-identifier hs-var">adt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-355"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679167796"><span class="annot"><span class="annottext">errors :: [AtError]
</span><a href="#local-6989586621679167796"><span class="hs-identifier hs-var hs-var">errors</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ADTParts -&gt; [AtError]
</span><a href="ZM.Parser.Env.html#uniqueLocalTypeNames"><span class="hs-identifier hs-var">uniqueLocalTypeNames</span></a></span><span> </span><span class="annot"><span class="annottext">ADTParts
</span><a href="#local-6989586621679167797"><span class="hs-identifier hs-var">adt</span></a></span><span> </span><span class="annot"><span class="annottext">[AtError] -&gt; [AtError] -&gt; [AtError]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">ADTParts -&gt; [AtError]
</span><a href="ZM.Parser.Env.html#uniqueConstrNames"><span class="hs-identifier hs-var">uniqueConstrNames</span></a></span><span> </span><span class="annot"><span class="annottext">ADTParts
</span><a href="#local-6989586621679167797"><span class="hs-identifier hs-var">adt</span></a></span><span>
</span><span id="line-356"></span><span>      </span><span class="hs-comment">--cons = (contree . constrs $ adt) &gt;&gt;= traverse (varOrName (M.fromList (zip (map object $ vars adt) [0..])))</span><span>
</span><span id="line-357"></span><span>      </span><span id="local-6989586621679167793"><span class="annot"><span class="annottext">cons :: Maybe (ConTree AtId TRef)
</span><a href="#local-6989586621679167793"><span class="hs-identifier hs-var hs-var">cons</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-358"></span><span>        </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Identifier Word8 -&gt; At (TypeName Identifier) -&gt; TRef
</span><a href="#local-6989586621679167792"><span class="hs-identifier hs-var">varOrName</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[(Identifier, Word8)] -&gt; Map Identifier Word8
forall k a. Ord k =&gt; [(k, a)] -&gt; Map k a
</span><span class="hs-identifier hs-var">M.fromList</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Identifier] -&gt; [Word8] -&gt; [(Identifier, Word8)]
forall a b. [a] -&gt; [b] -&gt; [(a, b)]
</span><span class="hs-identifier hs-var">zip</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(AtId -&gt; Identifier) -&gt; [AtId] -&gt; [Identifier]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">AtId -&gt; Identifier
forall l a. Label l a -&gt; a
</span><a href="ZM.Parser.Types.html#object"><span class="hs-identifier hs-var hs-var">object</span></a></span><span> </span><span class="annot"><span class="annottext">([AtId] -&gt; [Identifier]) -&gt; [AtId] -&gt; [Identifier]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">ADTParts -&gt; [AtId]
</span><a href="ZM.Parser.Types.html#vars"><span class="hs-identifier hs-var hs-var">vars</span></a></span><span> </span><span class="annot"><span class="annottext">ADTParts
</span><a href="#local-6989586621679167797"><span class="hs-identifier hs-var">adt</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Word8
</span><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">..</span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(At (TypeName Identifier) -&gt; TRef)
-&gt; ConTree AtId (At (TypeName Identifier)) -&gt; ConTree AtId TRef
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(ConTree AtId (At (TypeName Identifier)) -&gt; ConTree AtId TRef)
-&gt; Maybe (ConTree AtId (At (TypeName Identifier)))
-&gt; Maybe (ConTree AtId TRef)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span>
</span><span id="line-359"></span><span>        </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[(AtId, Fields AtId (At (TypeName Identifier)))]
-&gt; Maybe (ConTree AtId (At (TypeName Identifier)))
forall name ref.
[(name, Fields name ref)] -&gt; Maybe (ConTree name ref)
</span><span class="hs-identifier hs-var">contree</span></span><span> </span><span class="annot"><span class="annottext">([(AtId, Fields AtId (At (TypeName Identifier)))]
 -&gt; Maybe (ConTree AtId (At (TypeName Identifier))))
-&gt; (ADTParts -&gt; [(AtId, Fields AtId (At (TypeName Identifier)))])
-&gt; ADTParts
-&gt; Maybe (ConTree AtId (At (TypeName Identifier)))
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">ADTParts -&gt; [(AtId, Fields AtId (At (TypeName Identifier)))]
</span><a href="ZM.Parser.Types.html#constrs"><span class="hs-identifier hs-var hs-var">constrs</span></a></span><span> </span><span class="annot"><span class="annottext">(ADTParts -&gt; Maybe (ConTree AtId (At (TypeName Identifier))))
-&gt; ADTParts -&gt; Maybe (ConTree AtId (At (TypeName Identifier)))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">ADTParts
</span><a href="#local-6989586621679167797"><span class="hs-identifier hs-var">adt</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-360"></span><span>   </span><span class="hs-keyword">in</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">[AtError] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">[AtError]
</span><a href="#local-6989586621679167796"><span class="hs-identifier hs-var">errors</span></a></span><span>
</span><span id="line-361"></span><span>        </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">(At (TypeName Identifier), ADT AtId AtId TRef)
-&gt; Either [AtError] (At (TypeName Identifier), ADT AtId AtId TRef)
forall a b. b -&gt; Either a b
</span><span class="hs-identifier hs-var">Right</span></span><span>
</span><span id="line-362"></span><span>               </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">ADTParts -&gt; At (TypeName Identifier)
</span><a href="ZM.Parser.Types.html#name"><span class="hs-identifier hs-var hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">ADTParts
</span><a href="#local-6989586621679167797"><span class="hs-identifier hs-var">adt</span></a></span><span>
</span><span id="line-363"></span><span>               </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ADT :: forall name consName ref.
name
-&gt; Word8 -&gt; Maybe (ConTree consName ref) -&gt; ADT name consName ref
</span><span class="hs-identifier hs-type">ADT</span></span><span>
</span><span id="line-364"></span><span>                   </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">declName :: AtId
</span><span class="hs-identifier hs-var">declName</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TypeName Identifier -&gt; Identifier
forall a b. These a b -&gt; a
</span><a href="ZM.Parser.Types.html#localTypeName"><span class="hs-identifier hs-var">localTypeName</span></a></span><span> </span><span class="annot"><span class="annottext">(TypeName Identifier -&gt; Identifier)
-&gt; At (TypeName Identifier) -&gt; AtId
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ADTParts -&gt; At (TypeName Identifier)
</span><a href="ZM.Parser.Types.html#name"><span class="hs-identifier hs-var hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">ADTParts
</span><a href="#local-6989586621679167797"><span class="hs-identifier hs-var">adt</span></a></span><span>
</span><span id="line-365"></span><span>                   </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">declNumParameters :: Word8
</span><span class="hs-identifier hs-var">declNumParameters</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Word8
forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[AtId] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ADTParts -&gt; [AtId]
</span><a href="ZM.Parser.Types.html#vars"><span class="hs-identifier hs-var hs-var">vars</span></a></span><span> </span><span class="annot"><span class="annottext">ADTParts
</span><a href="#local-6989586621679167797"><span class="hs-identifier hs-var">adt</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-366"></span><span>                   </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">declCons :: Maybe (ConTree AtId TRef)
</span><span class="hs-identifier hs-var">declCons</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe (ConTree AtId TRef)
</span><a href="#local-6989586621679167793"><span class="hs-identifier hs-var">cons</span></a></span><span>
</span><span id="line-367"></span><span>                   </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-368"></span><span>        </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">[AtError]
-&gt; Either [AtError] (At (TypeName Identifier), ADT AtId AtId TRef)
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="annot"><span class="annottext">[AtError]
</span><a href="#local-6989586621679167796"><span class="hs-identifier hs-var">errors</span></a></span><span>
</span><span id="line-369"></span><span>  </span><span class="hs-comment">-- Variable names take precedence over type declarations</span><span>
</span><span id="line-370"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-371"></span><span>    </span><span class="annot"><a href="#local-6989586621679167792"><span class="hs-identifier hs-type">varOrName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">M.Map</span></span><span> </span><span class="annot"><a href="ZM.Types.html#Identifier"><span class="hs-identifier hs-type">Identifier</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word8</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="ZM.Parser.Types.html#At"><span class="hs-identifier hs-type">At</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Parser.Types.html#TypeName"><span class="hs-identifier hs-type">TypeName</span></a></span><span> </span><span class="annot"><a href="ZM.Types.html#Identifier"><span class="hs-identifier hs-type">Identifier</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="ZM.Parser.Env.html#TRef"><span class="hs-identifier hs-type">TRef</span></a></span><span>
</span><span id="line-372"></span><span>  </span><span class="hs-comment">-- varOrName vs r@(Label l (TypeName n (Just _))) = Ext2 r</span><span>
</span><span id="line-373"></span><span>  </span><span class="hs-comment">-- varOrName vs r@(Label l (TypeName n Nothing)) =</span><span>
</span><span id="line-374"></span><span>    </span><span id="local-6989586621679167792"><span class="annot"><span class="annottext">varOrName :: Map Identifier Word8 -&gt; At (TypeName Identifier) -&gt; TRef
</span><a href="#local-6989586621679167792"><span class="hs-identifier hs-var hs-var">varOrName</span></a></span></span><span> </span><span id="local-6989586621679167784"><span class="annot"><span class="annottext">Map Identifier Word8
</span><a href="#local-6989586621679167784"><span class="hs-identifier hs-var">vs</span></a></span></span><span> </span><span id="local-6989586621679167783"><span class="annot"><span class="annottext">r :: At (TypeName Identifier)
</span><a href="#local-6989586621679167783"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="ZM.Parser.Types.html#Label"><span class="hs-identifier hs-type">Label</span></a></span><span> </span><span id="local-6989586621679167782"><span class="annot"><span class="annottext">Range
</span><a href="#local-6989586621679167782"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679167781"><span class="annot"><span class="annottext">TypeName Identifier
</span><a href="#local-6989586621679167781"><span class="hs-identifier hs-var">tn</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-375"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">TypeName Identifier -&gt; Bool
forall a1 a. These a1 a -&gt; Bool
</span><a href="ZM.Parser.Types.html#hasRef"><span class="hs-identifier hs-var">hasRef</span></a></span><span> </span><span class="annot"><span class="annottext">TypeName Identifier
</span><a href="#local-6989586621679167781"><span class="hs-identifier hs-var">tn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">At (TypeName Identifier) -&gt; TRef
forall v r. r -&gt; TypeRef2 v r
</span><a href="ZM.Abs.html#Ext2"><span class="hs-identifier hs-var">Ext2</span></a></span><span> </span><span class="annot"><span class="annottext">At (TypeName Identifier)
</span><a href="#local-6989586621679167783"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-376"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-377"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679167778"><span class="annot"><span class="annottext">n :: Identifier
</span><a href="#local-6989586621679167778"><span class="hs-identifier hs-var hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TypeName Identifier -&gt; Identifier
forall a b. These a b -&gt; a
</span><a href="ZM.Parser.Types.html#localTypeName"><span class="hs-identifier hs-var">localTypeName</span></a></span><span> </span><span class="annot"><span class="annottext">TypeName Identifier
</span><a href="#local-6989586621679167781"><span class="hs-identifier hs-var">tn</span></a></span><span>
</span><span id="line-378"></span><span>         </span><span class="hs-keyword">in</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Identifier -&gt; Map Identifier Word8 -&gt; Maybe Word8
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><span class="hs-identifier hs-var">M.lookup</span></span><span> </span><span class="annot"><span class="annottext">Identifier
</span><a href="#local-6989586621679167778"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Map Identifier Word8
</span><a href="#local-6989586621679167784"><span class="hs-identifier hs-var">vs</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-379"></span><span>              </span><span class="annot"><span class="annottext">Maybe Word8
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">At (TypeName Identifier) -&gt; TRef
forall v r. r -&gt; TypeRef2 v r
</span><a href="ZM.Abs.html#Ext2"><span class="hs-identifier hs-var">Ext2</span></a></span><span> </span><span class="annot"><span class="annottext">At (TypeName Identifier)
</span><a href="#local-6989586621679167783"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="hs-comment">-- . asQualName &lt;$&gt; n</span><span>
</span><span id="line-380"></span><span>              </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679167776"><span class="annot"><span class="annottext">Word8
</span><a href="#local-6989586621679167776"><span class="hs-identifier hs-var">i</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Label (Range, Word8) Identifier -&gt; TRef
forall v r. v -&gt; TypeRef2 v r
</span><a href="ZM.Abs.html#Var2"><span class="hs-identifier hs-var">Var2</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Range, Word8) -&gt; Identifier -&gt; Label (Range, Word8) Identifier
forall l a. l -&gt; a -&gt; Label l a
</span><a href="ZM.Parser.Types.html#Label"><span class="hs-identifier hs-var">Label</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Range
</span><a href="#local-6989586621679167782"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Word8
</span><a href="#local-6989586621679167776"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Identifier
</span><a href="#local-6989586621679167778"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-381"></span><span>
</span><span id="line-382"></span><span id="local-6989586621679167905"><span id="local-6989586621679167906"><span id="local-6989586621679167907"><span class="annot"><a href="ZM.Parser.Env.html#asRef"><span class="hs-identifier hs-type">asRef</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="ZM.Abs.html#TypeRef2"><span class="hs-identifier hs-type">TypeRef2</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Parser.Types.html#Label"><span class="hs-identifier hs-type">Label</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679167907"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word8</span></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679167906"><span class="hs-identifier hs-type">a1</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679167905"><span class="hs-identifier hs-type">name</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TypeRef</span></span><span> </span><span class="annot"><a href="#local-6989586621679167905"><span class="hs-identifier hs-type">name</span></a></span></span></span></span><span>
</span><span id="line-383"></span><span id="asRef"><span class="annot"><span class="annottext">asRef :: TypeRef2 (Label (a, Word8) a1) name -&gt; TypeRef name
</span><a href="ZM.Parser.Env.html#asRef"><span class="hs-identifier hs-var hs-var">asRef</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Abs.html#Ext2"><span class="hs-identifier hs-type">Ext2</span></a></span><span> </span><span id="local-6989586621679167774"><span class="annot"><span class="annottext">name
</span><a href="#local-6989586621679167774"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span>                </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">name -&gt; TypeRef name
forall name. name -&gt; TypeRef name
</span><span class="hs-identifier hs-var">TypRef</span></span><span> </span><span class="annot"><span class="annottext">name
</span><a href="#local-6989586621679167774"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-384"></span><span class="annot"><a href="ZM.Parser.Env.html#asRef"><span class="hs-identifier hs-var">asRef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Abs.html#Var2"><span class="hs-identifier hs-type">Var2</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="ZM.Parser.Types.html#Label"><span class="hs-identifier hs-type">Label</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679167772"><span class="annot"><span class="annottext">Word8
</span><a href="#local-6989586621679167772"><span class="hs-identifier hs-var">i</span></a></span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">a1
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Word8 -&gt; TypeRef name
forall name. Word8 -&gt; TypeRef name
</span><span class="hs-identifier hs-var">TypVar</span></span><span> </span><span class="annot"><span class="annottext">Word8
</span><a href="#local-6989586621679167772"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="hs-comment">-- (Label l (TypeName n Nothing))</span><span>
</span><span id="line-385"></span><span>  </span><span class="hs-comment">-- varOrName vs r@(At l (TypeName n (Just _))) = TypRef r</span><span>
</span><span id="line-386"></span><span>  </span><span class="hs-comment">-- varOrNameT vs r@(At l (TypeName n Nothing)) =</span><span>
</span><span id="line-387"></span><span>  </span><span class="hs-comment">--    case M.lookup n vs of</span><span>
</span><span id="line-388"></span><span>  </span><span class="hs-comment">--          -- Nothing -&gt; Just $ TypRef . asQualName &lt;$&gt; n</span><span>
</span><span id="line-389"></span><span>  </span><span class="hs-comment">--          Just i -&gt; Just $ TypVar i</span><span>
</span><span id="line-390"></span><span>
</span><span id="line-391"></span><span class="hs-comment">--uniqueADTName adts = dupErrors &quot;data type declaration&quot; $ map name adts</span><span>
</span><span id="line-392"></span><span class="hs-comment">-- Locally defined type names (the adt name plus the variables names) must be unique</span><span>
</span><span id="line-393"></span><span class="annot"><a href="ZM.Parser.Env.html#uniqueLocalTypeNames"><span class="hs-identifier hs-type">uniqueLocalTypeNames</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="ZM.Parser.Types.html#ADTParts"><span class="hs-identifier hs-type">ADTParts</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="ZM.Parser.Types.html#Label"><span class="hs-identifier hs-type">Label</span></a></span><span> </span><span class="annot"><a href="ZM.Parser.Types.html#Range"><span class="hs-identifier hs-type">Range</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span>
</span><span id="line-394"></span><span id="uniqueLocalTypeNames"><span class="annot"><span class="annottext">uniqueLocalTypeNames :: ADTParts -&gt; [AtError]
</span><a href="ZM.Parser.Env.html#uniqueLocalTypeNames"><span class="hs-identifier hs-var hs-var">uniqueLocalTypeNames</span></a></span></span><span> </span><span id="local-6989586621679167770"><span class="annot"><span class="annottext">ADTParts
</span><a href="#local-6989586621679167770"><span class="hs-identifier hs-var">adt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-395"></span><span>  </span><span class="annot"><span class="annottext">String -&gt; [AtId] -&gt; [AtError]
forall (f :: * -&gt; *) a.
(Eq (f a), Pretty a, Functor f) =&gt;
String -&gt; [f a] -&gt; [f String]
</span><a href="ZM.Parser.Env.html#dupErrors"><span class="hs-identifier hs-var">dupErrors</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;type name&quot;</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">TypeName Identifier -&gt; Identifier
forall a b. These a b -&gt; a
</span><a href="ZM.Parser.Types.html#localTypeName"><span class="hs-identifier hs-var">localTypeName</span></a></span><span> </span><span class="annot"><span class="annottext">(TypeName Identifier -&gt; Identifier)
-&gt; At (TypeName Identifier) -&gt; AtId
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ADTParts -&gt; At (TypeName Identifier)
</span><a href="ZM.Parser.Types.html#name"><span class="hs-identifier hs-var hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">ADTParts
</span><a href="#local-6989586621679167770"><span class="hs-identifier hs-var">adt</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">AtId -&gt; [AtId] -&gt; [AtId]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">ADTParts -&gt; [AtId]
</span><a href="ZM.Parser.Types.html#vars"><span class="hs-identifier hs-var hs-var">vars</span></a></span><span> </span><span class="annot"><span class="annottext">ADTParts
</span><a href="#local-6989586621679167770"><span class="hs-identifier hs-var">adt</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-396"></span><span>
</span><span id="line-397"></span><span class="annot"><a href="ZM.Parser.Env.html#uniqueConstrNames"><span class="hs-identifier hs-type">uniqueConstrNames</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="ZM.Parser.Types.html#ADTParts"><span class="hs-identifier hs-type">ADTParts</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="ZM.Parser.Types.html#Label"><span class="hs-identifier hs-type">Label</span></a></span><span> </span><span class="annot"><a href="ZM.Parser.Types.html#Range"><span class="hs-identifier hs-type">Range</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span>
</span><span id="line-398"></span><span id="uniqueConstrNames"><span class="annot"><span class="annottext">uniqueConstrNames :: ADTParts -&gt; [AtError]
</span><a href="ZM.Parser.Env.html#uniqueConstrNames"><span class="hs-identifier hs-var hs-var">uniqueConstrNames</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; [AtId] -&gt; [AtError]
forall (f :: * -&gt; *) a.
(Eq (f a), Pretty a, Functor f) =&gt;
String -&gt; [f a] -&gt; [f String]
</span><a href="ZM.Parser.Env.html#dupErrors"><span class="hs-identifier hs-var">dupErrors</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;constructor&quot;</span></span><span> </span><span class="annot"><span class="annottext">([AtId] -&gt; [AtError])
-&gt; (ADTParts -&gt; [AtId]) -&gt; ADTParts -&gt; [AtError]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">((AtId, Fields AtId (At (TypeName Identifier))) -&gt; AtId)
-&gt; [(AtId, Fields AtId (At (TypeName Identifier)))] -&gt; [AtId]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">(AtId, Fields AtId (At (TypeName Identifier))) -&gt; AtId
forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span> </span><span class="annot"><span class="annottext">([(AtId, Fields AtId (At (TypeName Identifier)))] -&gt; [AtId])
-&gt; (ADTParts -&gt; [(AtId, Fields AtId (At (TypeName Identifier)))])
-&gt; ADTParts
-&gt; [AtId]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">ADTParts -&gt; [(AtId, Fields AtId (At (TypeName Identifier)))]
</span><a href="ZM.Parser.Types.html#constrs"><span class="hs-identifier hs-var hs-var">constrs</span></a></span><span>
</span><span id="line-399"></span><span>
</span><span id="line-400"></span><span class="hs-comment">--dupError kind = testErrors dups (\ds -&gt; [unwords [&quot;Duplicated&quot;,kind++&quot;:&quot;,unwords ds]])</span><span>
</span><span id="line-401"></span><span class="hs-comment">-- dupErrors :: String -&gt; [AtName] -&gt; [AtError]</span><span>
</span><span id="line-402"></span><span id="local-6989586621679167869"><span id="local-6989586621679167870"><span class="annot"><a href="ZM.Parser.Env.html#dupErrors"><span class="hs-identifier hs-type">dupErrors</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679167870"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679167869"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pretty</span></span><span> </span><span class="annot"><a href="#local-6989586621679167869"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Functor</span></span><span> </span><span class="annot"><a href="#local-6989586621679167870"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679167870"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679167869"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679167870"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span></span></span><span>
</span><span id="line-403"></span><span id="dupErrors"><span class="annot"><span class="annottext">dupErrors :: String -&gt; [f a] -&gt; [f String]
</span><a href="ZM.Parser.Env.html#dupErrors"><span class="hs-identifier hs-var hs-var">dupErrors</span></a></span></span><span> </span><span id="local-6989586621679167768"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679167768"><span class="hs-identifier hs-var">kind</span></a></span></span><span> </span><span id="local-6989586621679167767"><span class="annot"><span class="annottext">[f a]
</span><a href="#local-6989586621679167767"><span class="hs-identifier hs-var">vs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-404"></span><span>  </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679167766"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679167766"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; String
</span><span class="hs-identifier hs-var">unwords</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Duplicated&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679167768"><span class="hs-identifier hs-var">kind</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;:&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">a -&gt; String
forall a. Pretty a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">prettyShow</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679167766"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(a -&gt; String) -&gt; f a -&gt; f String
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(f a -&gt; f String) -&gt; [f a] -&gt; [f String]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">([f a] -&gt; [f String]) -&gt; [f a] -&gt; [f String]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-405"></span><span>  </span><span class="annot"><span class="annottext">[f a] -&gt; [f a]
forall a. Eq a =&gt; [a] -&gt; [a]
</span><a href="ZM.Parser.Env.html#dups"><span class="hs-identifier hs-var">dups</span></a></span><span> </span><span class="annot"><span class="annottext">[f a]
</span><a href="#local-6989586621679167767"><span class="hs-identifier hs-var">vs</span></a></span><span>
</span><span id="line-406"></span><span>
</span><span id="line-407"></span><span id="local-6989586621679167866"><span class="annot"><a href="ZM.Parser.Env.html#dups"><span class="hs-identifier hs-type">dups</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679167866"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679167866"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679167866"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-408"></span><span id="dups"><span class="annot"><span class="annottext">dups :: [a] -&gt; [a]
</span><a href="ZM.Parser.Env.html#dups"><span class="hs-identifier hs-var hs-var">dups</span></a></span></span><span> </span><span id="local-6989586621679167763"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679167763"><span class="hs-identifier hs-var">ls</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679167763"><span class="hs-identifier hs-var">ls</span></a></span><span> </span><span class="annot"><span class="annottext">[a] -&gt; [a] -&gt; [a]
forall a. Eq a =&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">\\</span></span><span> </span><span class="annot"><span class="annottext">[a] -&gt; [a]
forall a. Eq a =&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">nub</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679167763"><span class="hs-identifier hs-var">ls</span></a></span><span>
</span><span id="line-409"></span><span class="hs-comment">-- dups :: Eq a =&gt; [a] -&gt; [a]</span><span>
</span><span id="line-410"></span><span class="hs-comment">-- dups ls = deleteFirstsBy atEq ls (nubBy atEq ls)</span><span>
</span><span id="line-411"></span><span class="hs-comment">-- -- makeADT :: String -&gt; [String] -&gt; [(String, Fields String String)] -&gt; Either Errors (QualName, ADT String String (TypeRef QualName))</span><span>
</span><span id="line-412"></span><span class="hs-comment">-- makeADT :: ADTParts -&gt; Either Errors (QualName, ADT AName AName (TypeRef QualName))</span><span>
</span><span id="line-413"></span><span class="hs-comment">-- -- makeADT :: ADTParts -&gt; Either Errors (QualName, ADT String String (TypeRef QualName))</span><span>
</span><span id="line-414"></span><span class="hs-comment">-- makeADT adt =</span><span>
</span><span id="line-415"></span><span class="hs-comment">--   let</span><span>
</span><span id="line-416"></span><span class="hs-comment">--       eqn = parseQN (name adt)</span><span>
</span><span id="line-417"></span><span class="hs-comment">--       econstrs = case contree (constrs adt) of</span><span>
</span><span id="line-418"></span><span class="hs-comment">--                    Nothing -&gt; Success Nothing</span><span>
</span><span id="line-419"></span><span class="hs-comment">--                    Just ct -&gt; Just &lt;$&gt; traverse (varOrName (M.fromList (zip (vars adt) [0..]))) ct</span><span>
</span><span id="line-420"></span><span class="hs-comment">--       nameClashError = if (name adt) `elem` vars adt then Failure [&quot;data type name equal to a variable&quot;] else Success ()</span><span>
</span><span id="line-421"></span><span class="hs-comment">--       constrNames = map fst (constrs adt)</span><span>
</span><span id="line-422"></span><span class="hs-comment">--       constrDupErrors = dupErrors &quot;constructors&quot; constrNames</span><span>
</span><span id="line-423"></span><span class="hs-comment">--       varDupErrors = dupErrors &quot;variables&quot; (vars adt)</span><span>
</span><span id="line-424"></span><span class="hs-comment">--       constrNameErrors = idErrors constrNames</span><span>
</span><span id="line-425"></span><span class="hs-comment">--       varNameErrors = idErrors (vars adt)</span><span>
</span><span id="line-426"></span><span class="hs-comment">--   in validationToEither $</span><span>
</span><span id="line-427"></span><span class="hs-comment">--      (\qn constrs -&gt; (qn,ADT {declName=locName &lt;$&gt; qn</span><span>
</span><span id="line-428"></span><span class="hs-comment">--                              ,declNumParameters=fromIntegral (length (vars adt))</span><span>
</span><span id="line-429"></span><span class="hs-comment">--                              ,declCons = constrs})) &lt;$&gt; eqn &lt;*&gt; econstrs &lt;* nameClashError &lt;* varDupErrors &lt;* constrDupErrors &lt;* constrNameErrors &lt;* varNameErrors</span><span>
</span><span id="line-430"></span><span class="hs-comment">--idErrors :: [String] -&gt; Validation Errors [Identifier]</span><span>
</span><span id="line-431"></span><span class="hs-comment">--idErrors = traverse (asIdentifier . object)</span><span>
</span><span id="line-432"></span><span class="hs-comment">--dupError :: String -&gt; [String] -&gt; Validation Errors [String]</span><span>
</span><span id="line-433"></span><span class="hs-comment">--dupError kind = testErrors dups (\ds -&gt; [unwords [&quot;Duplicated&quot;,kind++&quot;:&quot;,unwords ds]])</span><span>
</span><span id="line-434"></span><span class="hs-comment">-- dupErrors kind vs =</span><span>
</span><span id="line-435"></span><span class="hs-comment">--   (((\n -&gt; unwords [&quot;Duplicated&quot;, kind, n]) &lt;$&gt;) &lt;$&gt;) $ dups vs</span><span>
</span><span id="line-436"></span><span class="hs-comment">-- dupErrors kind vs = ((\n -&gt; unwords [&quot;Duplicated&quot;,kind,object n]) &lt;$&gt;) $ dups vs</span><span>
</span><span id="line-437"></span><span class="hs-comment">-- testErrors :: Foldable t =&gt; (a1 -&gt; t a2) -&gt; (t a2 -&gt; e) -&gt; a1 -&gt; Validation e a1</span><span>
</span><span id="line-438"></span><span class="hs-comment">-- testErrors tst onErrs i =</span><span>
</span><span id="line-439"></span><span class="hs-comment">--   let errs = tst i</span><span>
</span><span id="line-440"></span><span class="hs-comment">--   in if null errs</span><span>
</span><span id="line-441"></span><span class="hs-comment">--        then Success i</span><span>
</span><span id="line-442"></span><span class="hs-comment">--        else Failure . onErrs $ errs</span><span>
</span><span id="line-443"></span><span class="hs-comment">-- dups :: Eq a =&gt; [a] -&gt; [a]</span><span>
</span><span id="line-444"></span><span class="hs-comment">-- dups ls = ls \\ nub ls</span><span>
</span><span id="line-445"></span><span class="hs-comment">-- varOrName ::</span><span>
</span><span id="line-446"></span><span class="hs-comment">--   M.Map String Word8</span><span>
</span><span id="line-447"></span><span class="hs-comment">--   -&gt; String -&gt; Validation Errors (TypeRef QualName)</span><span>
</span><span id="line-448"></span><span class="hs-comment">-- varOrName vs n =</span><span>
</span><span id="line-449"></span><span class="hs-comment">--   case M.lookup n vs of</span><span>
</span><span id="line-450"></span><span class="hs-comment">--     Nothing -&gt; TypRef &lt;$&gt; parseQN n</span><span>
</span><span id="line-451"></span><span class="hs-comment">--     Just i -&gt; pure $ TypVar i -- const (TypVar i) &lt;$&gt; identifier n</span><span>
</span><span id="line-452"></span><span class="hs-comment">--parseQN :: String -&gt; Either Errors QualName</span><span>
</span><span id="line-453"></span><span class="hs-comment">-- parseQN :: String -&gt; Validation Errors QualName</span><span>
</span><span id="line-454"></span><span class="hs-comment">--parseQN = eitherToValidation . convertResultToErrors . safeConvert --asIdentifier :: String -&gt; Either Errors Identifier</span><span>
</span><span id="line-455"></span><span class="hs-comment">--asIdentifier = convertResultToErrors . safeConvert</span><span>
</span><span id="line-456"></span><span class="hs-comment">--readDataTypes :: String -&gt; Either Errors AbsEnv</span><span>
</span><span id="line-457"></span><span class="hs-comment">-- readDataTypes src = undefined</span><span>
</span><span id="line-458"></span><span class="hs-comment">--   parse src &gt;&gt;= relToAbsEnv &gt;&gt;= validationToEither . testErrors kindErrors id</span><span>
</span><span id="line-459"></span><span class="hs-comment">-- -- parse :: String -&gt; Either String AbsEnv</span><span>
</span><span id="line-460"></span><span class="hs-comment">-- parse ::</span><span>
</span><span id="line-461"></span><span class="hs-comment">--      String</span><span>
</span><span id="line-462"></span><span class="hs-comment">--   -&gt; Either [String] (M.Map QualName (ADT String String (TypeRef QualName)))</span><span>
</span><span id="line-463"></span><span class="hs-comment">-- parse src = M.fromList &lt;$&gt; (alexScanTokens &gt;=&gt; parser) src</span><span>
</span><span id="line-464"></span></pre></body></html>